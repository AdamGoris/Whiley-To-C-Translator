// ===========================================================================
// This file has been generated by
// Rats! Parser Generator, version 2.4.0,
// (C) 2004-2014 Robert Grimm,
// on Friday, 30 August 2019 at 12:57:28 PM.
// Edit at your own risk.
// ===========================================================================

package whiley;

import java.io.Reader;
import java.io.IOException;

import java.util.HashSet;
import java.util.Set;

import xtc.util.Pair;
import scala.Option;
import scala.collection.immutable.Vector;
import sbtrats.ParserSupport;
import sbtrats.SVector;



import xtc.parser.ParserBase;
import xtc.parser.Column;
import xtc.parser.Result;
import xtc.parser.SemanticValue;
import xtc.parser.ParseError;

import whiley.WhileyISyntax.*;

import sbtrats.Action;
import xtc.tree.Location;
import org.bitbucket.inkytonik.kiama.parsing.Input;
import org.bitbucket.inkytonik.kiama.util.FileSource;
import org.bitbucket.inkytonik.kiama.util.Message;
import org.bitbucket.inkytonik.kiama.util.Position;
import org.bitbucket.inkytonik.kiama.util.Positions;
import org.bitbucket.inkytonik.kiama.util.Source;

/**
 * Packrat parser for grammar <code>whiley.WhileyI</code>.
 *
 * <p />This class has been generated by the <i>Rats!</i> parser
 * generator, version 2.4.0, (C) 2004-2014 Robert Grimm.
 */

public final class WhileyI extends ParserBase {

  // =========================================================================

  /** The Kiama source from which input is being read. */
  protected Source source;

  /** The Kiama position store being used to track value positions. */
  protected Positions positions;

  /**
   * Create a new packrat parser.
   *
   * @param src The Kiama source to be parsed.
   * @param posns The store in which to keep track of parsed value positions.
   * @throws NullPointerException Signals a null file name.
   * @throws IllegalArgumentException Signals a negative file size.
   */
  public WhileyI(final Source src, final Positions posns) {
      this(src, INIT_SIZE - 1, posns);
  }

  /**
   * Create a new packrat parser.
   *
   * @param src The Kiama source to be parsed.
   * @param size The length of the character stream.
   * @param posns The store in which to keep track of parsed value positions.
   * @throws NullPointerException Signals a null file name.
   * @throws IllegalArgumentException Signals a negative file size.
   */
  public WhileyI(final Source src, final int size, final Positions posns) {
      this(src.reader(), src.optName().isEmpty() ? "" : src.optName().get(), size);
      source = src;
      positions = posns;
  }

  /** Set start position of an Object to one that corresponds to a start
   *  index and the finish position to the one that corresponds to the
   *  current parsing index. */
  void setLocation(final Object object, final int start) {
    if (null != object) {
      Column s = column(start);
      positions.setStart(object, new Position(s.line, s.column, source));
      int finish = yyCount == 0 ? 0 : yyCount - 1;
      Column f = column(finish);
      positions.setFinish(object, new Position(f.line, f.column, source));
    }
  }

  /** Set the start position of an Object to the start position of
   *  another object and the finish position to one that corresponds to
   *  the current parsing index. If the source object doesn't have a
   *  start position, do nothing. */
  void copyLocation(final Object object, final Object another) {
    if ((null != object) && (null != another)) {
      scala.Option<Position> optStart = positions.getStart(another);
      if (!optStart.isEmpty()) {
        scala.Option<Object> optOffset = optStart.get().optOffset();
        if (!optOffset.isEmpty())
          setLocation(object, ((Integer)optOffset.get()).intValue());
      }
    }
  }

  /** Return a Kiama message for a given parse error. */
  public Message errorToMessage(ParseError error) {
    Location loc = location(error.index);
    Position pos = new Position(loc.line, loc.column, source);
    positions.setStart(error, pos);
    positions.setFinish(error, pos);
    return new Message(error, error.msg);
  }

  /** Return a Kiama input for a given parse index. */
  public Input indexToInput(int index) {
    return new Input(source, index);
  }


  /** The KEYWORDS set. */
  public static final Set<String> KEYWORDS = new HashSet<String>();

  // =========================================================================

  /** Chunk 1 of memoized results. */
  static final class Chunk1 {
    Result fSymbol1;
    Result fSymbol2;
    Result fStm;
    Result fStm$$Star1;
    Result fStm$$Star2;
    Result fStm$$Star3;
    Result fStm$$Star4;
    Result fStm$$Star5;
    Result fStm$$Star6;
    Result fStm$$Star7;
  }

  /** Chunk 2 of memoized results. */
  static final class Chunk2 {
    Result fStm$$Star8;
    Result fStm$$Star9;
    Result fType;
    Result fExp;
    Result fAssign;
    Result fWhereExpr;
    Result fRequiresEnsures;
    Result fParameters;
    Result fParameters$$Star1;
    Result fReturnType;
  }

  /** Chunk 3 of memoized results. */
  static final class Chunk3 {
    Result fLVal;
    Result fLoc;
    Result fCommExp;
    Result fCommTypeLoc;
    Result fLocOrStar;
    Result fTypeLoc;
    Result fExpLevel0;
    Result fExpLevel5;
    Result fExpLevel5$$Star1;
    Result fExpLevel1;
  }

  /** Chunk 4 of memoized results. */
  static final class Chunk4 {
    Result fExpLevel1$$Star1;
    Result fExpLevel6;
    Result fExpLevel6$$Star1;
    Result fExpLevel9;
    Result fExpLevel9$$Star1;
    Result fExpLevel2;
    Result fExpLevel2$$Star1;
    Result fExpLevel7;
    Result fExpLevel7$$Star1;
    Result fExpLevel3;
  }

  /** Chunk 5 of memoized results. */
  static final class Chunk5 {
    Result fExpLevel3$$Star1;
    Result fExpLevel8;
    Result fExpLevel4;
    Result fExpLevel4$$Star1;
    Result fIdentifier;
    Result fWord;
  }

  // =========================================================================

  /** Memoization table column. */
  static final class WhileyIColumn extends Column {
    Chunk1 chunk1;
    Chunk2 chunk2;
    Chunk3 chunk3;
    Chunk4 chunk4;
    Chunk5 chunk5;
  }

  // =========================================================================

  /**
   * Create a new packrat parser.
   *
   * @param reader The reader.
   * @param file The file name.
   */
  public WhileyI(final Reader reader, final String file) {
    super(reader, file);
  }

  /**
   * Create a new packrat parser.
   *
   * @param reader The file reader.
   * @param file The file name.
   * @param size The file size.
   */
  public WhileyI(final Reader reader, final String file, final int size) {
    super(reader, file, size);
  }

  // =========================================================================

  protected Column newColumn() {
    return new WhileyIColumn();
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.Symbol1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSymbol1(final int yyStart) throws IOException {
    WhileyIColumn yyColumn = (WhileyIColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fSymbol1) 
      yyColumn.chunk1.fSymbol1 = pSymbol1$1(yyStart);
    return yyColumn.chunk1.fSymbol1;
  }

  /** Actually parse whiley.WhileyI.Symbol1. */
  private Result pSymbol1$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol1Alts(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.Symbol1Alts.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSymbol1Alts(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '*':
        {
          yyValue = "*";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '%':
        {
          yyValue = "%";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '}':
        {
          yyValue = "}";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '.':
        {
          yyValue = ".";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case ']':
        {
          yyValue = "]";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '=':
        {
          yyValue = "=";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '<':
        {
          yyValue = "<";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '&':
        {
          yyValue = "&";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '!':
        {
          yyValue = "!";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '|':
        {
          yyValue = "|";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case ')':
        {
          yyValue = ")";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '-':
        {
          yyValue = "-";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case ',':
        {
          yyValue = ",";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case ';':
        {
          yyValue = ";";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '[':
        {
          yyValue = "[";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '{':
        {
          yyValue = "{";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '0':
        {
          yyValue = "0";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '+':
        {
          yyValue = "+";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '(':
        {
          yyValue = "(";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case ':':
        {
          yyValue = ":";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '^':
        {
          yyValue = "^";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '/':
        {
          yyValue = "/";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '>':
        {
          yyValue = ">";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("symbol1 alts expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.Symbol2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSymbol2(final int yyStart) throws IOException {
    WhileyIColumn yyColumn = (WhileyIColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fSymbol2) 
      yyColumn.chunk1.fSymbol2 = pSymbol2$1(yyStart);
    return yyColumn.chunk1.fSymbol2;
  }

  /** Actually parse whiley.WhileyI.Symbol2. */
  private Result pSymbol2$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol2Alts(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.Symbol2Alts.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSymbol2Alts(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '0':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('b' == yyC) {

              yyValue = "0b";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '<':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case '=':
              {
                yyValue = "<=";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            case '<':
              {
                yyValue = "<<";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }
        }
        break;

      case '-':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('>' == yyC) {

              yyValue = "->";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '|':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('|' == yyC) {

              yyValue = "||";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '>':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;

            switch (yyC) {
            case '=':
              {
                yyValue = ">=";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            case '>':
              {
                yyValue = ">>";

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

            default:
              /* No match. */
            }
          }
        }
        break;

      case '=':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('=' == yyC) {

              yyValue = "==";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '[':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if (']' == yyC) {

              yyValue = "[]";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '!':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('=' == yyC) {

              yyValue = "!=";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      case '&':
        {
          yyC = character(yyIndex);
          if (-1 != yyC) {
            yyIndex = yyIndex + 1;
            if ('&' == yyC) {

              yyValue = "&&";

              return new SemanticValue(yyValue, yyIndex, yyError);
            }
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("symbol2 alts expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.Symbol7.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSymbol7(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol7Alts(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.Symbol7Alts.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSymbol7Alts(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('e' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('l' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('s' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('e' == yyC) {
            yyIndex = yyIndex + 1;

            yyC = character(yyIndex);
            if (' ' == yyC) {
              yyIndex = yyIndex + 1;

              yyC = character(yyIndex);
              if ('i' == yyC) {
                yyIndex = yyIndex + 1;

                yyC = character(yyIndex);
                if ('f' == yyC) {
                  yyIndex = yyIndex + 1;

                  yyValue = "else if";

                  return new SemanticValue(yyValue, yyIndex, yyError);
                }
              }
            }
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("symbol7 alts expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.Symbol3.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSymbol3(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol3Alts(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.Symbol3Alts.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSymbol3Alts(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('=' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('=' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('>' == yyC) {
          yyIndex = yyIndex + 1;

          yyValue = "==>";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }
      }
    }

    // Done.
    yyError = yyError.select("symbol3 alts expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.Symbol4.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSymbol4(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol4Alts(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.Symbol4Alts.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSymbol4Alts(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('<' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('=' == yyC) {
        yyIndex = yyIndex + 1;

        yyC = character(yyIndex);
        if ('=' == yyC) {
          yyIndex = yyIndex + 1;

          yyC = character(yyIndex);
          if ('>' == yyC) {
            yyIndex = yyIndex + 1;

            yyValue = "<==>";

            return new SemanticValue(yyValue, yyIndex, yyError);
          }
        }
      }
    }

    // Done.
    yyError = yyError.select("symbol4 alts expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.Program.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pProgram(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Vector<Stm>  yyRepValue1;
    Program    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSpacing(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyRepetition1 = yyResult.index;
      yyRepValue1   = SVector.empty();
      while (true) {

        yyResult = pStm(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          Stm v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = SVector.create(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v1.
        Vector<Stm> v1 = SVector.reverse(yyRepValue1);

        yyResult = pEOF(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = new Program (v1);

          if (yyValue instanceof Object) {
            setLocation((Object)yyValue, yyStart);
          }
          return yyResult.createValue(yyValue, yyError);
        }
      } // End scope for v1.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.Stm.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pStm(final int yyStart) throws IOException {
    WhileyIColumn yyColumn = (WhileyIColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fStm) yyColumn.chunk1.fStm = pStm$1(yyStart);
    return yyColumn.chunk1.fStm;
  }

  /** Actually parse whiley.WhileyI.Stm. */
  private Result pStm$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Object     yyOpValue1;
    Stm        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("package")) {

      yyResult = pLoc(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Loc v1 = yyResult.semanticValue();

        yyResult = pStm$$Star1(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Vector<DotLoc> v2 = yyResult.semanticValue();

          yyValue = new PackageDecl (v1, v2);

          if (yyValue instanceof Object) {
            setLocation((Object)yyValue, yyStart);
          }
          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 2.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("import")) {

      yyResult = pLocOrStar(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        LocOrStar v1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pWord(yyBase);
        if (yyResult.hasValue("from")) {

          yyResult = pLoc(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Loc v2 = yyResult.semanticValue();

            yyResult = pStm$$Star2(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Vector<DotLocOrStar> v3 = yyResult.semanticValue();

              yyValue = new ImportDecl (v1, v2, v3);

              if (yyValue instanceof Object) {
                setLocation((Object)yyValue, yyStart);
              }
              return yyResult.createValue(yyValue, yyError);
            }
          }
        } else {
          yyError = yyError.select("'from' expected", yyBase);
        }
      }
    }

    // Alternative 3.

    yyResult = pModifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Modifier v1 = yyResult.semanticValue();

      yyResult = pStm(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Stm v2 = yyResult.semanticValue();

        yyValue = new Modify (v1, v2);

        if (yyValue instanceof Object) {
          setLocation((Object)yyValue, yyStart);
        }
        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 4.

    yyResult = pType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Type v1 = yyResult.semanticValue();

      yyResult = pLVal(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        LVal v2 = yyResult.semanticValue();

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyResult = pStm$$Star3(yyChoice1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Vector<CommTypeLoc> v3 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol1(yyBase);
          if (yyResult.hasValue("=")) {

            yyResult = pExp(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Exp v4 = yyResult.semanticValue();

              yyResult = pStm$$Star4(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Vector<CommExp> v5 = yyResult.semanticValue();

                yyValue = new DeclAsgn (v1, v2, v3, v4, v5);

                if (yyValue instanceof Object) {
                  setLocation((Object)yyValue, yyStart);
                }
                return yyResult.createValue(yyValue, yyError);
              }
            }
          } else {
            yyError = yyError.select("'=' expected", yyBase);
          }
        }

        // Nested alternative 2.

        yyValue = new Decl (v1, v2);

        if (yyValue instanceof Object) {
          setLocation((Object)yyValue, yyStart);
        }
        return new SemanticValue(yyValue, yyChoice1, yyError);
      }
    }

    // Alternative 5.

    yyResult = pAssign(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Exp v1 = yyResult.semanticValue();

      yyValue = new Asgn (v1);

      if (yyValue instanceof Object) {
        setLocation((Object)yyValue, yyStart);
      }
      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = pTypeDeclaration(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      TypeDeclaration v1 = yyResult.semanticValue();

      yyValue = new TypeDecl (v1);

      if (yyValue instanceof Object) {
        setLocation((Object)yyValue, yyStart);
      }
      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 7.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("const")) {

      yyResult = pLoc(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Loc v1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pWord(yyBase);
        if (yyResult.hasValue("is")) {

          yyResult = pExp(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Exp v2 = yyResult.semanticValue();

            yyValue = new ConstDecl (v1, v2);

            if (yyValue instanceof Object) {
              setLocation((Object)yyValue, yyStart);
            }
            return yyResult.createValue(yyValue, yyError);
          }
        } else {
          yyError = yyError.select("'is' expected", yyBase);
        }
      }
    }

    // Alternative 8.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("if")) {

      yyBase   = yyResult.index;
      yyResult = pSymbol1(yyBase);
      if (yyResult.hasValue("(")) {

        yyResult = pExp(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Exp v1 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol1(yyBase);
          if (yyResult.hasValue(")")) {

            yyBase   = yyResult.index;
            yyResult = pSymbol1(yyBase);
            if (yyResult.hasValue(":")) {

              yyResult = pStm(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Stm v2 = yyResult.semanticValue();

                yyResult = pStm$$Star5(yyResult.index);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  Vector<ElseIf> v3 = yyResult.semanticValue();

                  yyOption1  = yyResult.index;
                  yyOpValue1 = null;

                  yyResult = pElse(yyOption1);
                  yyError  = yyResult.select(yyError, yyOption1);
                  if (yyResult.hasValue()) {
                    Else v$el$11 = yyResult.semanticValue();

                    yyOption1  = yyResult.index;
                    yyOpValue1 = v$el$11;
                  }
                  { // Start scope for v4.
                    Else v4 = cast(yyOpValue1);

                    yyValue = new If (v1, v2, v3, Option.apply (v4));

                    if (yyValue instanceof Object) {
                      setLocation((Object)yyValue, yyStart);
                    }
                    return new SemanticValue(yyValue, yyOption1, yyError);
                  } // End scope for v4.
                }
              }
            } else {
              yyError = yyError.select("':' expected", yyBase);
            }
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }
    }

    // Alternative 9.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("switch")) {

      yyResult = pExp(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Exp v1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol1(yyBase);
        if (yyResult.hasValue(":")) {

          yyResult = pCaseStm(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            CaseStm v2 = yyResult.semanticValue();

            yyValue = new Switch (v1, v2);

            if (yyValue instanceof Object) {
              setLocation((Object)yyValue, yyStart);
            }
            return yyResult.createValue(yyValue, yyError);
          }
        } else {
          yyError = yyError.select("':' expected", yyBase);
        }
      }
    }

    // Alternative 10.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("while")) {

      yyBase   = yyResult.index;
      yyResult = pSymbol1(yyBase);
      if (yyResult.hasValue("(")) {

        yyResult = pExp(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Exp v1 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol1(yyBase);
          if (yyResult.hasValue(")")) {

            yyBase   = yyResult.index;
            yyResult = pSymbol1(yyBase);
            if (yyResult.hasValue(":")) {

              yyResult = pStm(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Stm v2 = yyResult.semanticValue();

                yyValue = new While (v1, v2);

                if (yyValue instanceof Object) {
                  setLocation((Object)yyValue, yyStart);
                }
                return yyResult.createValue(yyValue, yyError);
              }
            } else {
              yyError = yyError.select("':' expected", yyBase);
            }
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }
    }

    // Alternative 11.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("do")) {

      yyBase   = yyResult.index;
      yyResult = pSymbol1(yyBase);
      if (yyResult.hasValue(":")) {

        yyResult = pStm(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Stm v1 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pWord(yyBase);
          if (yyResult.hasValue("while")) {

            yyResult = pExp(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Exp v2 = yyResult.semanticValue();

              yyResult = pStm$$Star6(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Vector<WhereExpr> v3 = yyResult.semanticValue();

                yyValue = new DoWhile (v1, v2, v3);

                if (yyValue instanceof Object) {
                  setLocation((Object)yyValue, yyStart);
                }
                return yyResult.createValue(yyValue, yyError);
              }
            }
          } else {
            yyError = yyError.select("'while' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("':' expected", yyBase);
      }
    }

    // Alternative 12.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("function")) {

      yyResult = pLoc(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Loc v1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol1(yyBase);
        if (yyResult.hasValue("(")) {

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pParameters(yyOption1);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {
            Parameters v$el$14 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$14;
          }
          { // Start scope for v2.
            Parameters v2 = cast(yyOpValue1);

            yyBase   = yyOption1;
            yyResult = pSymbol1(yyBase);
            if (yyResult.hasValue(")")) {

              yyOption1  = yyResult.index;
              yyOpValue1 = null;

              yyResult = pReturnType(yyOption1);
              yyError  = yyResult.select(yyError, yyOption1);
              if (yyResult.hasValue()) {
                ReturnType v$el$15 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$15;
              }
              { // Start scope for v3.
                ReturnType v3 = cast(yyOpValue1);

                yyResult = pStm$$Star7(yyOption1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  Vector<RequiresEnsures> v4 = yyResult.semanticValue();

                  yyBase   = yyResult.index;
                  yyResult = pSymbol1(yyBase);
                  if (yyResult.hasValue(":")) {

                    yyResult = pStm(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      Stm v5 = yyResult.semanticValue();

                      yyValue = new FnDecl (v1, Option.apply (v2), Option.apply (v3), v4, v5);

                      if (yyValue instanceof Object) {
                        setLocation((Object)yyValue, yyStart);
                      }
                      return yyResult.createValue(yyValue, yyError);
                    }
                  } else {
                    yyError = yyError.select("':' expected", yyBase);
                  }
                }
              } // End scope for v3.
            } else {
              yyError = yyError.select("')' expected", yyBase);
            }
          } // End scope for v2.
        } else {
          yyError = yyError.select("'(' expected", yyBase);
        }
      }
    }

    // Alternative 13.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("method")) {

      yyResult = pLoc(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Loc v1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol1(yyBase);
        if (yyResult.hasValue("(")) {

          yyOption1  = yyResult.index;
          yyOpValue1 = null;

          yyResult = pParameters(yyOption1);
          yyError  = yyResult.select(yyError, yyOption1);
          if (yyResult.hasValue()) {
            Parameters v$el$18 = yyResult.semanticValue();

            yyOption1  = yyResult.index;
            yyOpValue1 = v$el$18;
          }
          { // Start scope for v2.
            Parameters v2 = cast(yyOpValue1);

            yyBase   = yyOption1;
            yyResult = pSymbol1(yyBase);
            if (yyResult.hasValue(")")) {

              yyOption1  = yyResult.index;
              yyOpValue1 = null;

              yyResult = pReturnType(yyOption1);
              yyError  = yyResult.select(yyError, yyOption1);
              if (yyResult.hasValue()) {
                ReturnType v$el$19 = yyResult.semanticValue();

                yyOption1  = yyResult.index;
                yyOpValue1 = v$el$19;
              }
              { // Start scope for v3.
                ReturnType v3 = cast(yyOpValue1);

                yyResult = pStm$$Star8(yyOption1);
                yyError  = yyResult.select(yyError);
                if (yyResult.hasValue()) {
                  Vector<RequiresEnsures> v4 = yyResult.semanticValue();

                  yyBase   = yyResult.index;
                  yyResult = pSymbol1(yyBase);
                  if (yyResult.hasValue(":")) {

                    yyResult = pStm(yyResult.index);
                    yyError  = yyResult.select(yyError);
                    if (yyResult.hasValue()) {
                      Stm v5 = yyResult.semanticValue();

                      yyValue = new MthdDecl (v1, Option.apply (v2), Option.apply (v3), v4, v5);

                      if (yyValue instanceof Object) {
                        setLocation((Object)yyValue, yyStart);
                      }
                      return yyResult.createValue(yyValue, yyError);
                    }
                  } else {
                    yyError = yyError.select("':' expected", yyBase);
                  }
                }
              } // End scope for v3.
            } else {
              yyError = yyError.select("')' expected", yyBase);
            }
          } // End scope for v2.
        } else {
          yyError = yyError.select("'(' expected", yyBase);
        }
      }
    }

    // Alternative 14.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("return")) {

      yyResult = pExp(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Exp v1 = yyResult.semanticValue();

        yyResult = pStm$$Star9(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Vector<CommExp> v2 = yyResult.semanticValue();

          yyValue = new RtnStm (v1, v2);

          if (yyValue instanceof Object) {
            setLocation((Object)yyValue, yyStart);
          }
          return yyResult.createValue(yyValue, yyError);
        }
      }
    }

    // Alternative 15.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("assert")) {

      yyResult = pExp(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Exp v1 = yyResult.semanticValue();

        yyValue = new Assert (v1);

        if (yyValue instanceof Object) {
          setLocation((Object)yyValue, yyStart);
        }
        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 16.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("assume")) {

      yyResult = pExp(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Exp v1 = yyResult.semanticValue();

        yyValue = new Assume (v1);

        if (yyValue instanceof Object) {
          setLocation((Object)yyValue, yyStart);
        }
        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 17.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("debug")) {

      yyResult = pExp(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Exp v1 = yyResult.semanticValue();

        yyValue = new DebugExp (v1);

        if (yyValue instanceof Object) {
          setLocation((Object)yyValue, yyStart);
        }
        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 18.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("skip")) {

      yyValue = new SkipStm ();

      if (yyValue instanceof Object) {
        setLocation((Object)yyValue, yyStart);
      }
      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 19.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("break")) {

      yyValue = new BreakStm ();

      if (yyValue instanceof Object) {
        setLocation((Object)yyValue, yyStart);
      }
      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 20.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("continue")) {

      yyValue = new ContStm ();

      if (yyValue instanceof Object) {
        setLocation((Object)yyValue, yyStart);
      }
      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 21.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("fail")) {

      yyValue = new FailStm ();

      if (yyValue instanceof Object) {
        setLocation((Object)yyValue, yyStart);
      }
      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("stm expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal whiley.WhileyI.Stm$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStm$$Star1(final int yyStart) throws IOException {
    WhileyIColumn yyColumn = (WhileyIColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fStm$$Star1) 
      yyColumn.chunk1.fStm$$Star1 = pStm$$Star1$1(yyStart);
    return yyColumn.chunk1.fStm$$Star1;
  }

  /** Actually parse whiley.WhileyI.Stm$$Star1. */
  private Result pStm$$Star1$1(final int yyStart) throws IOException {
    Result       yyResult;
    Vector<DotLoc> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pDotLoc(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      DotLoc v$el$1 = yyResult.semanticValue();

      yyResult = pStm$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Vector<DotLoc> v$2 = yyResult.semanticValue();

        yyValue = SVector.create(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = SVector.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal whiley.WhileyI.Stm$$Star2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStm$$Star2(final int yyStart) throws IOException {
    WhileyIColumn yyColumn = (WhileyIColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fStm$$Star2) 
      yyColumn.chunk1.fStm$$Star2 = pStm$$Star2$1(yyStart);
    return yyColumn.chunk1.fStm$$Star2;
  }

  /** Actually parse whiley.WhileyI.Stm$$Star2. */
  private Result pStm$$Star2$1(final int yyStart) throws IOException {
    Result             yyResult;
    Vector<DotLocOrStar> yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pDotLocOrStar(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      DotLocOrStar v$el$3 = yyResult.semanticValue();

      yyResult = pStm$$Star2(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Vector<DotLocOrStar> v$4 = yyResult.semanticValue();

        yyValue = SVector.create(v$el$3, v$4);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = SVector.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal whiley.WhileyI.Stm$$Star3.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStm$$Star3(final int yyStart) throws IOException {
    WhileyIColumn yyColumn = (WhileyIColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fStm$$Star3) 
      yyColumn.chunk1.fStm$$Star3 = pStm$$Star3$1(yyStart);
    return yyColumn.chunk1.fStm$$Star3;
  }

  /** Actually parse whiley.WhileyI.Stm$$Star3. */
  private Result pStm$$Star3$1(final int yyStart) throws IOException {
    Result            yyResult;
    Vector<CommTypeLoc> yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCommTypeLoc(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      CommTypeLoc v$el$5 = yyResult.semanticValue();

      yyResult = pStm$$Star3(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Vector<CommTypeLoc> v$6 = yyResult.semanticValue();

        yyValue = SVector.create(v$el$5, v$6);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = SVector.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal whiley.WhileyI.Stm$$Star4.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStm$$Star4(final int yyStart) throws IOException {
    WhileyIColumn yyColumn = (WhileyIColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fStm$$Star4) 
      yyColumn.chunk1.fStm$$Star4 = pStm$$Star4$1(yyStart);
    return yyColumn.chunk1.fStm$$Star4;
  }

  /** Actually parse whiley.WhileyI.Stm$$Star4. */
  private Result pStm$$Star4$1(final int yyStart) throws IOException {
    Result        yyResult;
    Vector<CommExp> yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCommExp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      CommExp v$el$7 = yyResult.semanticValue();

      yyResult = pStm$$Star4(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Vector<CommExp> v$8 = yyResult.semanticValue();

        yyValue = SVector.create(v$el$7, v$8);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = SVector.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal whiley.WhileyI.Stm$$Star5.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStm$$Star5(final int yyStart) throws IOException {
    WhileyIColumn yyColumn = (WhileyIColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fStm$$Star5) 
      yyColumn.chunk1.fStm$$Star5 = pStm$$Star5$1(yyStart);
    return yyColumn.chunk1.fStm$$Star5;
  }

  /** Actually parse whiley.WhileyI.Stm$$Star5. */
  private Result pStm$$Star5$1(final int yyStart) throws IOException {
    Result       yyResult;
    Vector<ElseIf> yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pElseIf(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      ElseIf v$el$9 = yyResult.semanticValue();

      yyResult = pStm$$Star5(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Vector<ElseIf> v$10 = yyResult.semanticValue();

        yyValue = SVector.create(v$el$9, v$10);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = SVector.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal whiley.WhileyI.Stm$$Star6.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStm$$Star6(final int yyStart) throws IOException {
    WhileyIColumn yyColumn = (WhileyIColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fStm$$Star6) 
      yyColumn.chunk1.fStm$$Star6 = pStm$$Star6$1(yyStart);
    return yyColumn.chunk1.fStm$$Star6;
  }

  /** Actually parse whiley.WhileyI.Stm$$Star6. */
  private Result pStm$$Star6$1(final int yyStart) throws IOException {
    Result          yyResult;
    Vector<WhereExpr> yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWhereExpr(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      WhereExpr v$el$12 = yyResult.semanticValue();

      yyResult = pStm$$Star6(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Vector<WhereExpr> v$13 = yyResult.semanticValue();

        yyValue = SVector.create(v$el$12, v$13);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = SVector.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal whiley.WhileyI.Stm$$Star7.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStm$$Star7(final int yyStart) throws IOException {
    WhileyIColumn yyColumn = (WhileyIColumn)column(yyStart);
    if (null == yyColumn.chunk1) yyColumn.chunk1 = new Chunk1();
    if (null == yyColumn.chunk1.fStm$$Star7) 
      yyColumn.chunk1.fStm$$Star7 = pStm$$Star7$1(yyStart);
    return yyColumn.chunk1.fStm$$Star7;
  }

  /** Actually parse whiley.WhileyI.Stm$$Star7. */
  private Result pStm$$Star7$1(final int yyStart) throws IOException {
    Result                yyResult;
    Vector<RequiresEnsures> yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pRequiresEnsures(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      RequiresEnsures v$el$16 = yyResult.semanticValue();

      yyResult = pStm$$Star7(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Vector<RequiresEnsures> v$17 = yyResult.semanticValue();

        yyValue = SVector.create(v$el$16, v$17);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = SVector.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal whiley.WhileyI.Stm$$Star8.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStm$$Star8(final int yyStart) throws IOException {
    WhileyIColumn yyColumn = (WhileyIColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fStm$$Star8) 
      yyColumn.chunk2.fStm$$Star8 = pStm$$Star8$1(yyStart);
    return yyColumn.chunk2.fStm$$Star8;
  }

  /** Actually parse whiley.WhileyI.Stm$$Star8. */
  private Result pStm$$Star8$1(final int yyStart) throws IOException {
    Result                yyResult;
    Vector<RequiresEnsures> yyValue;
    ParseError            yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pRequiresEnsures(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      RequiresEnsures v$el$20 = yyResult.semanticValue();

      yyResult = pStm$$Star8(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Vector<RequiresEnsures> v$21 = yyResult.semanticValue();

        yyValue = SVector.create(v$el$20, v$21);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = SVector.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal whiley.WhileyI.Stm$$Star9.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pStm$$Star9(final int yyStart) throws IOException {
    WhileyIColumn yyColumn = (WhileyIColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fStm$$Star9) 
      yyColumn.chunk2.fStm$$Star9 = pStm$$Star9$1(yyStart);
    return yyColumn.chunk2.fStm$$Star9;
  }

  /** Actually parse whiley.WhileyI.Stm$$Star9. */
  private Result pStm$$Star9$1(final int yyStart) throws IOException {
    Result        yyResult;
    Vector<CommExp> yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCommExp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      CommExp v$el$22 = yyResult.semanticValue();

      yyResult = pStm$$Star9(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Vector<CommExp> v$23 = yyResult.semanticValue();

        yyValue = SVector.create(v$el$22, v$23);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = SVector.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.Type.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pType(final int yyStart) throws IOException {
    WhileyIColumn yyColumn = (WhileyIColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fType) 
      yyColumn.chunk2.fType = pType$1(yyStart);
    return yyColumn.chunk2.fType;
  }

  /** Actually parse whiley.WhileyI.Type. */
  private Result pType$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    int        yyOption1;
    Type       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("int")) {

      yyOption1  = yyResult.index;

      yyBase   = yyOption1;
      yyResult = pSymbol2(yyBase);
      if (yyResult.hasValue("[]")) {

        yyOption1  = yyResult.index;
      } else {
        yyError = yyError.select("'[]' expected", yyBase);
      }

      yyValue = new IntType ();

      if (yyValue instanceof Object) {
        setLocation((Object)yyValue, yyStart);
      }
      return new SemanticValue(yyValue, yyOption1, yyError);
    }

    // Alternative 2.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("byte")) {

      yyOption1  = yyResult.index;

      yyBase   = yyOption1;
      yyResult = pSymbol2(yyBase);
      if (yyResult.hasValue("[]")) {

        yyOption1  = yyResult.index;
      } else {
        yyError = yyError.select("'[]' expected", yyBase);
      }

      yyValue = new ByteType ();

      if (yyValue instanceof Object) {
        setLocation((Object)yyValue, yyStart);
      }
      return new SemanticValue(yyValue, yyOption1, yyError);
    }

    // Alternative 3.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("bool")) {

      yyOption1  = yyResult.index;

      yyBase   = yyOption1;
      yyResult = pSymbol2(yyBase);
      if (yyResult.hasValue("[]")) {

        yyOption1  = yyResult.index;
      } else {
        yyError = yyError.select("'[]' expected", yyBase);
      }

      yyValue = new BoolType ();

      if (yyValue instanceof Object) {
        setLocation((Object)yyValue, yyStart);
      }
      return new SemanticValue(yyValue, yyOption1, yyError);
    }

    // Done.
    yyError = yyError.select("type expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.RefType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pRefType(final int yyStart) throws IOException {
    Result     yyResult;
    RefType    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol1(yyStart);
    if (yyResult.hasValue("&")) {

      yyResult = pType(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Type v1 = yyResult.semanticValue();

        yyValue = new ReferenceType (v1);

        if (yyValue instanceof Object) {
          setLocation((Object)yyValue, yyStart);
        }
        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("ref type expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.Exp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pExp(final int yyStart) throws IOException {
    WhileyIColumn yyColumn = (WhileyIColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fExp) yyColumn.chunk2.fExp = pExp$1(yyStart);
    return yyColumn.chunk2.fExp;
  }

  /** Actually parse whiley.WhileyI.Exp. */
  private Result pExp$1(final int yyStart) throws IOException {
    Result     yyResult;
    Exp        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpLevel10(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Exp v1 = yyResult.semanticValue();

      yyValue = v1;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.Assign.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pAssign(final int yyStart) throws IOException {
    WhileyIColumn yyColumn = (WhileyIColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fAssign) 
      yyColumn.chunk2.fAssign = pAssign$1(yyStart);
    return yyColumn.chunk2.fAssign;
  }

  /** Actually parse whiley.WhileyI.Assign. */
  private Result pAssign$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Exp        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLVal(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      LVal v1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol1(yyBase);
      if (yyResult.hasValue("=")) {

        yyResult = pExp(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Exp v2 = yyResult.semanticValue();

          yyValue = new Assign (v1, v2);

          if (yyValue instanceof Object) {
            setLocation((Object)yyValue, yyStart);
          }
          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("'=' expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.TypeDeclaration.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pTypeDeclaration(final int yyStart) throws IOException {
    Result          yyResult;
    int             yyBase;
    int             yyRepetition1;
    Vector<WhereExpr> yyRepValue1;
    int             yyOption1;
    TypeDeclaration yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("type")) {

      yyResult = pLoc(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Loc v1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pWord(yyBase);
        if (yyResult.hasValue("is")) {

          final int yyChoice1 = yyResult.index;

          // Nested alternative 1.

          yyOption1  = yyChoice1;

          yyBase   = yyOption1;
          yyResult = pSymbol1(yyBase);
          if (yyResult.hasValue("(")) {

            yyOption1  = yyResult.index;
          } else {
            yyError = yyError.select("'(' expected", yyBase);
          }
          { // Start scope for nested choice.

            final int yyChoice2 = yyOption1;

            // Nested alternative 1.

            yyResult = pTypeLoc(yyChoice2);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              TypeLoc v2 = yyResult.semanticValue();

              yyOption1  = yyResult.index;

              yyBase   = yyOption1;
              yyResult = pSymbol1(yyBase);
              if (yyResult.hasValue(")")) {

                yyOption1  = yyResult.index;
              } else {
                yyError = yyError.select("')' expected", yyBase);
              }

              yyRepetition1 = yyOption1;
              yyRepValue1   = SVector.empty();
              while (true) {

                yyResult = pWhereExpr(yyRepetition1);
                yyError  = yyResult.select(yyError, yyRepetition1);
                if (yyResult.hasValue()) {
                  WhereExpr v$el$1 = yyResult.semanticValue();

                  yyRepetition1 = yyResult.index;
                  yyRepValue1   = SVector.create(v$el$1, yyRepValue1);
                  continue;
                }
                break;
              }
              { // Start scope for v3.
                Vector<WhereExpr> v3 = SVector.reverse(yyRepValue1);

                yyValue = new TypeDeclVar (v1, v2, v3);

                if (yyValue instanceof Object) {
                  setLocation((Object)yyValue, yyStart);
                }
                return new SemanticValue(yyValue, yyRepetition1, yyError);
              } // End scope for v3.
            }

            // Nested alternative 2.

            yyResult = pType(yyChoice2);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Type v2 = yyResult.semanticValue();

              yyOption1  = yyResult.index;

              yyBase   = yyOption1;
              yyResult = pSymbol1(yyBase);
              if (yyResult.hasValue(")")) {

                yyOption1  = yyResult.index;
              } else {
                yyError = yyError.select("')' expected", yyBase);
              }

              yyRepetition1 = yyOption1;
              yyRepValue1   = SVector.empty();
              while (true) {

                yyResult = pWhereExpr(yyRepetition1);
                yyError  = yyResult.select(yyError, yyRepetition1);
                if (yyResult.hasValue()) {
                  WhereExpr v$el$2 = yyResult.semanticValue();

                  yyRepetition1 = yyResult.index;
                  yyRepValue1   = SVector.create(v$el$2, yyRepValue1);
                  continue;
                }
                break;
              }
              { // Start scope for v3.
                Vector<WhereExpr> v3 = SVector.reverse(yyRepValue1);

                yyValue = new TypeDeclType (v1, v2, v3);

                if (yyValue instanceof Object) {
                  setLocation((Object)yyValue, yyStart);
                }
                return new SemanticValue(yyValue, yyRepetition1, yyError);
              } // End scope for v3.
            }
          } // End scope for nested choice.

          // Nested alternative 2.

          yyResult = pLambda(yyChoice1);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Lambda v2 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = SVector.empty();
            while (true) {

              yyResult = pWhereExpr(yyRepetition1);
              yyError  = yyResult.select(yyError, yyRepetition1);
              if (yyResult.hasValue()) {
                WhereExpr v$el$3 = yyResult.semanticValue();

                yyRepetition1 = yyResult.index;
                yyRepValue1   = SVector.create(v$el$3, yyRepValue1);
                continue;
              }
              break;
            }
            { // Start scope for v3.
              Vector<WhereExpr> v3 = SVector.reverse(yyRepValue1);

              yyValue = new TypeDeclLambda (v1, v2, v3);

              if (yyValue instanceof Object) {
                setLocation((Object)yyValue, yyStart);
              }
              return new SemanticValue(yyValue, yyRepetition1, yyError);
            } // End scope for v3.
          }
        } else {
          yyError = yyError.select("'is' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("type declaration expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.ArgList.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pArgList(final int yyStart) throws IOException {
    Result        yyResult;
    int           yyRepetition1;
    Vector<CommExp> yyRepValue1;
    ArgList       yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Exp v1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = SVector.empty();
      while (true) {

        yyResult = pCommExp(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          CommExp v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = SVector.create(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v2.
        Vector<CommExp> v2 = SVector.reverse(yyRepValue1);

        yyValue = new ArgList (v1, v2);

        if (yyValue instanceof Object) {
          setLocation((Object)yyValue, yyStart);
        }
        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.WhereExpr.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pWhereExpr(final int yyStart) throws IOException {
    WhileyIColumn yyColumn = (WhileyIColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fWhereExpr) 
      yyColumn.chunk2.fWhereExpr = pWhereExpr$1(yyStart);
    return yyColumn.chunk2.fWhereExpr;
  }

  /** Actually parse whiley.WhileyI.WhereExpr. */
  private Result pWhereExpr$1(final int yyStart) throws IOException {
    Result     yyResult;
    WhereExpr  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("where")) {

      yyResult = pExp(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Exp v1 = yyResult.semanticValue();

        yyValue = new WhereExp (v1);

        if (yyValue instanceof Object) {
          setLocation((Object)yyValue, yyStart);
        }
        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("where expr expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.QuantExp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pQuantExp(final int yyStart) throws IOException {
    Result             yyResult;
    int                yyBase;
    int                yyRepetition1;
    Vector<CommLocInExp> yyRepValue1;
    QuantExp           yyValue;
    ParseError         yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNoSomeAll(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      NoSomeAll v1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol1(yyBase);
      if (yyResult.hasValue("{")) {

        yyResult = pLoc(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Loc v2 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pWord(yyBase);
          if (yyResult.hasValue("in")) {

            yyResult = pExp(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Exp v3 = yyResult.semanticValue();

              yyRepetition1 = yyResult.index;
              yyRepValue1   = SVector.empty();
              while (true) {

                yyResult = pCommLocInExp(yyRepetition1);
                yyError  = yyResult.select(yyError, yyRepetition1);
                if (yyResult.hasValue()) {
                  CommLocInExp v$el$1 = yyResult.semanticValue();

                  yyRepetition1 = yyResult.index;
                  yyRepValue1   = SVector.create(v$el$1, yyRepValue1);
                  continue;
                }
                break;
              }
              { // Start scope for v4.
                Vector<CommLocInExp> v4 = SVector.reverse(yyRepValue1);

                yyBase   = yyRepetition1;
                yyResult = pSymbol1(yyBase);
                if (yyResult.hasValue("|")) {

                  yyResult = pExp(yyResult.index);
                  yyError  = yyResult.select(yyError);
                  if (yyResult.hasValue()) {
                    Exp v5 = yyResult.semanticValue();

                    yyBase   = yyResult.index;
                    yyResult = pSymbol1(yyBase);
                    if (yyResult.hasValue("}")) {

                      yyValue = new QuantExp (v1, v2, v3, v4, v5);

                      if (yyValue instanceof Object) {
                        setLocation((Object)yyValue, yyStart);
                      }
                      return yyResult.createValue(yyValue, yyError);
                    } else {
                      yyError = yyError.select("'}' expected", yyBase);
                    }
                  }
                } else {
                  yyError = yyError.select("'|' expected", yyBase);
                }
              } // End scope for v4.
            }
          } else {
            yyError = yyError.select("'in' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'{' expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.NoSomeAll.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pNoSomeAll(final int yyStart) throws IOException {
    Result     yyResult;
    NoSomeAll  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("no")) {

      yyValue = new No ();

      if (yyValue instanceof Object) {
        setLocation((Object)yyValue, yyStart);
      }
      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("some")) {

      yyValue = new Some ();

      if (yyValue instanceof Object) {
        setLocation((Object)yyValue, yyStart);
      }
      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("all")) {

      yyValue = new All ();

      if (yyValue instanceof Object) {
        setLocation((Object)yyValue, yyStart);
      }
      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("no some all expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.Lambda.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pLambda(final int yyStart) throws IOException {
    Result        yyResult;
    int           yyBase;
    int           yyRepetition1;
    Vector<TypeLoc> yyRepValue1;
    Lambda        yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("function")) {

      yyBase   = yyResult.index;
      yyResult = pSymbol1(yyBase);
      if (yyResult.hasValue("(")) {

        yyRepetition1 = yyResult.index;
        yyRepValue1   = SVector.empty();
        while (true) {

          yyResult = pTypeLoc(yyRepetition1);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            TypeLoc v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = SVector.create(v$el$1, yyRepValue1);
            continue;
          }
          break;
        }
        { // Start scope for v1.
          Vector<TypeLoc> v1 = SVector.reverse(yyRepValue1);

          yyBase   = yyRepetition1;
          yyResult = pSymbol1(yyBase);
          if (yyResult.hasValue(")")) {

            yyBase   = yyResult.index;
            yyResult = pSymbol2(yyBase);
            if (yyResult.hasValue("->")) {

              yyResult = pType(yyResult.index);
              yyError  = yyResult.select(yyError);
              if (yyResult.hasValue()) {
                Type v2 = yyResult.semanticValue();

                yyValue = new Lambda (v1, v2);

                if (yyValue instanceof Object) {
                  setLocation((Object)yyValue, yyStart);
                }
                return yyResult.createValue(yyValue, yyError);
              }
            } else {
              yyError = yyError.select("'->' expected", yyBase);
            }
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        } // End scope for v1.
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }
    }

    // Done.
    yyError = yyError.select("lambda expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.ElseIf.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pElseIf(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    ElseIf     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol7(yyStart);
    if (yyResult.hasValue("else if")) {

      yyResult = pExp(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Exp v1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol1(yyBase);
        if (yyResult.hasValue(":")) {

          yyResult = pStm(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Stm v2 = yyResult.semanticValue();

            yyValue = new ElseIf (v1, v2);

            if (yyValue instanceof Object) {
              setLocation((Object)yyValue, yyStart);
            }
            return yyResult.createValue(yyValue, yyError);
          }
        } else {
          yyError = yyError.select("':' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("else if expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.Else.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pElse(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Else       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("else")) {

      yyBase   = yyResult.index;
      yyResult = pSymbol1(yyBase);
      if (yyResult.hasValue(":")) {

        yyResult = pStm(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Stm v1 = yyResult.semanticValue();

          yyValue = new Else (v1);

          if (yyValue instanceof Object) {
            setLocation((Object)yyValue, yyStart);
          }
          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("':' expected", yyBase);
      }
    }

    // Done.
    yyError = yyError.select("else expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.CaseStm.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pCaseStm(final int yyStart) throws IOException {
    Result        yyResult;
    int           yyBase;
    int           yyRepetition1;
    Vector<CommExp> yyRepValue1;
    CaseStm       yyValue;
    ParseError    yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("case")) {

      yyResult = pExp(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Exp v1 = yyResult.semanticValue();

        yyRepetition1 = yyResult.index;
        yyRepValue1   = SVector.empty();
        while (true) {

          yyResult = pCommExp(yyRepetition1);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {
            CommExp v$el$1 = yyResult.semanticValue();

            yyRepetition1 = yyResult.index;
            yyRepValue1   = SVector.create(v$el$1, yyRepValue1);
            continue;
          }
          break;
        }
        { // Start scope for v2.
          Vector<CommExp> v2 = SVector.reverse(yyRepValue1);

          yyBase   = yyRepetition1;
          yyResult = pSymbol1(yyBase);
          if (yyResult.hasValue(":")) {

            yyResult = pStm(yyResult.index);
            yyError  = yyResult.select(yyError);
            if (yyResult.hasValue()) {
              Stm v3 = yyResult.semanticValue();

              yyValue = new Case (v1, v2, v3);

              if (yyValue instanceof Object) {
                setLocation((Object)yyValue, yyStart);
              }
              return yyResult.createValue(yyValue, yyError);
            }
          } else {
            yyError = yyError.select("':' expected", yyBase);
          }
        } // End scope for v2.
      }
    }

    // Alternative 2.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("default")) {

      yyBase   = yyResult.index;
      yyResult = pSymbol1(yyBase);
      if (yyResult.hasValue(":")) {

        yyResult = pStm(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Stm v1 = yyResult.semanticValue();

          yyValue = new DefaultCase (v1);

          if (yyValue instanceof Object) {
            setLocation((Object)yyValue, yyStart);
          }
          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("':' expected", yyBase);
      }
    }

    // Done.
    yyError = yyError.select("case stm expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.RequiresEnsures.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pRequiresEnsures(final int yyStart) throws IOException {
    WhileyIColumn yyColumn = (WhileyIColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fRequiresEnsures) 
      yyColumn.chunk2.fRequiresEnsures = pRequiresEnsures$1(yyStart);
    return yyColumn.chunk2.fRequiresEnsures;
  }

  /** Actually parse whiley.WhileyI.RequiresEnsures. */
  private Result pRequiresEnsures$1(final int yyStart) throws IOException {
    Result          yyResult;
    RequiresEnsures yyValue;
    ParseError      yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("requires")) {

      yyResult = pExp(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Exp v1 = yyResult.semanticValue();

        yyValue = new Requires (v1);

        if (yyValue instanceof Object) {
          setLocation((Object)yyValue, yyStart);
        }
        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("ensures")) {

      yyResult = pExp(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Exp v1 = yyResult.semanticValue();

        yyValue = new Ensures (v1);

        if (yyValue instanceof Object) {
          setLocation((Object)yyValue, yyStart);
        }
        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("requires ensures expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.Parameters.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pParameters(final int yyStart) throws IOException {
    WhileyIColumn yyColumn = (WhileyIColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fParameters) 
      yyColumn.chunk2.fParameters = pParameters$1(yyStart);
    return yyColumn.chunk2.fParameters;
  }

  /** Actually parse whiley.WhileyI.Parameters. */
  private Result pParameters$1(final int yyStart) throws IOException {
    Result     yyResult;
    Parameters yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pTypeLoc(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      TypeLoc v1 = yyResult.semanticValue();

      yyResult = pParameters$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Vector<CommTypeLoc> v2 = yyResult.semanticValue();

        yyValue = new Params (v1, v2);

        if (yyValue instanceof Object) {
          setLocation((Object)yyValue, yyStart);
        }
        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Type v1 = yyResult.semanticValue();

      yyValue = new TypeParam (v1);

      if (yyValue instanceof Object) {
        setLocation((Object)yyValue, yyStart);
      }
      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal whiley.WhileyI.Parameters$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pParameters$$Star1(final int yyStart) throws IOException {
    WhileyIColumn yyColumn = (WhileyIColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fParameters$$Star1) 
      yyColumn.chunk2.fParameters$$Star1 = pParameters$$Star1$1(yyStart);
    return yyColumn.chunk2.fParameters$$Star1;
  }

  /** Actually parse whiley.WhileyI.Parameters$$Star1. */
  private Result pParameters$$Star1$1(final int yyStart) throws IOException {
    Result            yyResult;
    Vector<CommTypeLoc> yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pCommTypeLoc(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      CommTypeLoc v$el$1 = yyResult.semanticValue();

      yyResult = pParameters$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Vector<CommTypeLoc> v$2 = yyResult.semanticValue();

        yyValue = SVector.create(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = SVector.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.ReturnType.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pReturnType(final int yyStart) throws IOException {
    WhileyIColumn yyColumn = (WhileyIColumn)column(yyStart);
    if (null == yyColumn.chunk2) yyColumn.chunk2 = new Chunk2();
    if (null == yyColumn.chunk2.fReturnType) 
      yyColumn.chunk2.fReturnType = pReturnType$1(yyStart);
    return yyColumn.chunk2.fReturnType;
  }

  /** Actually parse whiley.WhileyI.ReturnType. */
  private Result pReturnType$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    ReturnType yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol2(yyStart);
    if (yyResult.hasValue("->")) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyBase   = yyChoice1;
      yyResult = pSymbol1(yyBase);
      if (yyResult.hasValue("(")) {

        yyResult = pParameters(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Parameters v1 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol1(yyBase);
          if (yyResult.hasValue(")")) {

            yyValue = new RtnParams (v1);

            if (yyValue instanceof Object) {
              setLocation((Object)yyValue, yyStart);
            }
            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("')' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'(' expected", yyBase);
      }

      // Nested alternative 2.

      yyResult = pType(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Type v1 = yyResult.semanticValue();

        yyValue = new RtnType (v1);

        if (yyValue instanceof Object) {
          setLocation((Object)yyValue, yyStart);
        }
        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("return type expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.Modifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pModifier(final int yyStart) throws IOException {
    Result     yyResult;
    Modifier   yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("public")) {

      yyValue = new Public ();

      if (yyValue instanceof Object) {
        setLocation((Object)yyValue, yyStart);
      }
      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("private")) {

      yyValue = new Private ();

      if (yyValue instanceof Object) {
        setLocation((Object)yyValue, yyStart);
      }
      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("native")) {

      yyValue = new Native ();

      if (yyValue instanceof Object) {
        setLocation((Object)yyValue, yyStart);
      }
      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("export")) {

      yyValue = new Export ();

      if (yyValue instanceof Object) {
        setLocation((Object)yyValue, yyStart);
      }
      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("modifier expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.Lit.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pLit(final int yyStart) throws IOException {
    Result     yyResult;
    Exp        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pNullLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      NullLiteral v1 = yyResult.semanticValue();

      yyValue = new NullLit (v1);

      if (yyValue instanceof Object) {
        setLocation((Object)yyValue, yyStart);
      }
      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pByteLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Exp v1 = yyResult.semanticValue();

      yyValue = new ByteLit (v1);

      if (yyValue instanceof Object) {
        setLocation((Object)yyValue, yyStart);
      }
      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pIntegerLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v1 = yyResult.semanticValue();

      yyValue = new IntLit (Integer.parseInt (v1));

      if (yyValue instanceof Object) {
        setLocation((Object)yyValue, yyStart);
      }
      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 4.

    yyResult = pBooleanLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Exp v1 = yyResult.semanticValue();

      yyValue = new BoolLit (v1);

      if (yyValue instanceof Object) {
        setLocation((Object)yyValue, yyStart);
      }
      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.NullLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pNullLiteral(final int yyStart) throws IOException {
    Result      yyResult;
    NullLiteral yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("null")) {

      yyValue = new NullLiteral ();

      if (yyValue instanceof Object) {
        setLocation((Object)yyValue, yyStart);
      }
      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("null literal expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.ByteLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pByteLiteral(final int yyStart) throws IOException {
    Result       yyResult;
    int          yyRepetition1;
    Vector<String> yyRepValue1;
    Exp          yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol2(yyStart);
    if (yyResult.hasValue("0b")) {

      yyRepetition1 = yyResult.index;
      yyRepValue1   = SVector.empty();
      while (true) {

        yyResult = pBit(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          String v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = SVector.create(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v1.
        Vector<String> v1 = SVector.reverse(yyRepValue1);

        yyValue = new ByteLiteral (v1);

        if (yyValue instanceof Object) {
          setLocation((Object)yyValue, yyStart);
        }
        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v1.
    }

    // Done.
    yyError = yyError.select("byte literal expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.IntegerLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pIntegerLiteral(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pDecimalNumeral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.IntegerLiteralForm.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pIntegerLiteralForm(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '0':
        {
          yyValue = "0";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        {
          yyResult = pDigits(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = difference(yyStart, yyResult.index);

            return yyResult.createValue(yyValue, yyError);
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("integer literal form expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.DecimalNumeral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pDecimalNumeral(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '0':
        {
          yyValue = "0";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        {
          yyResult = pDigits(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = difference(yyStart, yyResult.index);

            return yyResult.createValue(yyValue, yyError);
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("decimal numeral expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.BooleanLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pBooleanLiteral(final int yyStart) throws IOException {
    Result     yyResult;
    Exp        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("false")) {

      yyValue = new False ();

      if (yyValue instanceof Object) {
        setLocation((Object)yyValue, yyStart);
      }
      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("true")) {

      yyValue = new True ();

      if (yyValue instanceof Object) {
        setLocation((Object)yyValue, yyStart);
      }
      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("boolean literal expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.Digits.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pDigits(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    while (true) {

      yyC = character(yyRepetition1);
      if (-1 != yyC) {
        yyIndex = yyRepetition1 + 1;

        switch (yyC) {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        default:
          /* No match. */
        }
      }
      break;
    }

    yyValue = difference(yyStart, yyRepetition1);

    return new SemanticValue(yyValue, yyRepetition1, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.NonZeroDigit.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pNonZeroDigit(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        {
          yyValue = difference(yyStart, yyIndex);

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("non zero digit expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.Digit.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pDigit(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        {
          yyValue = difference(yyStart, yyIndex);

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("digit expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.Bit.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pBit(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '0':
      case '1':
      case '|':
        {
          yyValue = difference(yyStart, yyIndex);

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("bit expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.LVal.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pLVal(final int yyStart) throws IOException {
    WhileyIColumn yyColumn = (WhileyIColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fLVal) 
      yyColumn.chunk3.fLVal = pLVal$1(yyStart);
    return yyColumn.chunk3.fLVal;
  }

  /** Actually parse whiley.WhileyI.LVal. */
  private Result pLVal$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    LVal       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLoc(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Loc v1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyBase   = yyChoice1;
      yyResult = pSymbol1(yyBase);
      if (yyResult.hasValue(".")) {

        yyResult = pIdentifier(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          String v2 = yyResult.semanticValue();

          yyValue = new FieldAsgn (v1, v2);

          if (yyValue instanceof Object) {
            setLocation((Object)yyValue, yyStart);
          }
          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("'.' expected", yyBase);
      }

      // Nested alternative 2.

      yyBase   = yyChoice1;
      yyResult = pSymbol1(yyBase);
      if (yyResult.hasValue("[")) {

        yyResult = pExp(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Exp v2 = yyResult.semanticValue();

          yyBase   = yyResult.index;
          yyResult = pSymbol1(yyBase);
          if (yyResult.hasValue("]")) {

            yyValue = new ListAsgn (v1, v2);

            if (yyValue instanceof Object) {
              setLocation((Object)yyValue, yyStart);
            }
            return yyResult.createValue(yyValue, yyError);
          } else {
            yyError = yyError.select("']' expected", yyBase);
          }
        }
      } else {
        yyError = yyError.select("'[' expected", yyBase);
      }
    }

    // Alternative 2.

    yyResult = pSymbol1(yyStart);
    if (yyResult.hasValue("*")) {

      yyResult = pExp(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Exp v1 = yyResult.semanticValue();

        yyValue = new Pointer (v1);

        if (yyValue instanceof Object) {
          setLocation((Object)yyValue, yyStart);
        }
        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 3.

    yyResult = pIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v1 = yyResult.semanticValue();

      yyValue = new IdnAsgn (v1);

      if (yyValue instanceof Object) {
        setLocation((Object)yyValue, yyStart);
      }
      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("l val expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.Loc.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pLoc(final int yyStart) throws IOException {
    WhileyIColumn yyColumn = (WhileyIColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fLoc) yyColumn.chunk3.fLoc = pLoc$1(yyStart);
    return yyColumn.chunk3.fLoc;
  }

  /** Actually parse whiley.WhileyI.Loc. */
  private Result pLoc$1(final int yyStart) throws IOException {
    Result     yyResult;
    Loc        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v1 = yyResult.semanticValue();

      yyValue = new Loc (v1);

      if (yyValue instanceof Object) {
        setLocation((Object)yyValue, yyStart);
      }
      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.Length.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pLength(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Exp        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol1(yyStart);
    if (yyResult.hasValue("|")) {

      yyResult = pLoc(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Loc v1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol1(yyBase);
        if (yyResult.hasValue("|")) {

          yyValue = new Len (v1);

          if (yyValue instanceof Object) {
            setLocation((Object)yyValue, yyStart);
          }
          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("'|' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("length expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.Lab.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pLab(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.CommExp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pCommExp(final int yyStart) throws IOException {
    WhileyIColumn yyColumn = (WhileyIColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fCommExp) 
      yyColumn.chunk3.fCommExp = pCommExp$1(yyStart);
    return yyColumn.chunk3.fCommExp;
  }

  /** Actually parse whiley.WhileyI.CommExp. */
  private Result pCommExp$1(final int yyStart) throws IOException {
    Result     yyResult;
    CommExp    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol1(yyStart);
    if (yyResult.hasValue(",")) {

      yyResult = pExp(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Exp v1 = yyResult.semanticValue();

        yyValue = new CommExp (v1);

        if (yyValue instanceof Object) {
          setLocation((Object)yyValue, yyStart);
        }
        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("comm exp expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.CommLoc.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pCommLoc(final int yyStart) throws IOException {
    Result     yyResult;
    CommLoc    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol1(yyStart);
    if (yyResult.hasValue(",")) {

      yyResult = pLoc(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Loc v1 = yyResult.semanticValue();

        yyValue = new CommLoc (v1);

        if (yyValue instanceof Object) {
          setLocation((Object)yyValue, yyStart);
        }
        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("comm loc expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.CommLocInExp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pCommLocInExp(final int yyStart) throws IOException {
    Result       yyResult;
    int          yyBase;
    CommLocInExp yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol1(yyStart);
    if (yyResult.hasValue(",")) {

      yyResult = pLoc(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Loc v1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pWord(yyBase);
        if (yyResult.hasValue("in")) {

          yyResult = pExp(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Exp v2 = yyResult.semanticValue();

            yyValue = new CommLocInExp (v1, v2);

            if (yyValue instanceof Object) {
              setLocation((Object)yyValue, yyStart);
            }
            return yyResult.createValue(yyValue, yyError);
          }
        } else {
          yyError = yyError.select("'in' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("comm loc in exp expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.CommTypeLoc.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pCommTypeLoc(final int yyStart) throws IOException {
    WhileyIColumn yyColumn = (WhileyIColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fCommTypeLoc) 
      yyColumn.chunk3.fCommTypeLoc = pCommTypeLoc$1(yyStart);
    return yyColumn.chunk3.fCommTypeLoc;
  }

  /** Actually parse whiley.WhileyI.CommTypeLoc. */
  private Result pCommTypeLoc$1(final int yyStart) throws IOException {
    Result      yyResult;
    CommTypeLoc yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol1(yyStart);
    if (yyResult.hasValue(",")) {

      yyResult = pTypeLoc(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        TypeLoc v1 = yyResult.semanticValue();

        yyValue = new CommTypeLoc (v1);

        if (yyValue instanceof Object) {
          setLocation((Object)yyValue, yyStart);
        }
        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("comm type loc expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.DotLoc.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pDotLoc(final int yyStart) throws IOException {
    Result     yyResult;
    DotLoc     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol1(yyStart);
    if (yyResult.hasValue(".")) {

      yyResult = pLoc(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Loc v1 = yyResult.semanticValue();

        yyValue = new DotLoc (v1);

        if (yyValue instanceof Object) {
          setLocation((Object)yyValue, yyStart);
        }
        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("dot loc expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.LocOrStar.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pLocOrStar(final int yyStart) throws IOException {
    WhileyIColumn yyColumn = (WhileyIColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fLocOrStar) 
      yyColumn.chunk3.fLocOrStar = pLocOrStar$1(yyStart);
    return yyColumn.chunk3.fLocOrStar;
  }

  /** Actually parse whiley.WhileyI.LocOrStar. */
  private Result pLocOrStar$1(final int yyStart) throws IOException {
    Result     yyResult;
    LocOrStar  yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol1(yyStart);
    if (yyResult.hasValue("*")) {

      yyValue = new ImpAll ();

      if (yyValue instanceof Object) {
        setLocation((Object)yyValue, yyStart);
      }
      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pLoc(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Loc v1 = yyResult.semanticValue();

      yyValue = new Spc (v1);

      if (yyValue instanceof Object) {
        setLocation((Object)yyValue, yyStart);
      }
      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("loc or star expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.DotLocOrStar.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pDotLocOrStar(final int yyStart) throws IOException {
    Result       yyResult;
    DotLocOrStar yyValue;
    ParseError   yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol1(yyStart);
    if (yyResult.hasValue(".")) {

      yyResult = pLocOrStar(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        LocOrStar v1 = yyResult.semanticValue();

        yyValue = new DotLocOrStar (v1);

        if (yyValue instanceof Object) {
          setLocation((Object)yyValue, yyStart);
        }
        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("dot loc or star expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.TypeLoc.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pTypeLoc(final int yyStart) throws IOException {
    WhileyIColumn yyColumn = (WhileyIColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fTypeLoc) 
      yyColumn.chunk3.fTypeLoc = pTypeLoc$1(yyStart);
    return yyColumn.chunk3.fTypeLoc;
  }

  /** Actually parse whiley.WhileyI.TypeLoc. */
  private Result pTypeLoc$1(final int yyStart) throws IOException {
    Result     yyResult;
    TypeLoc    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Type v1 = yyResult.semanticValue();

      yyResult = pLoc(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Loc v2 = yyResult.semanticValue();

        yyValue = new TypeLoc (v1, v2);

        if (yyValue instanceof Object) {
          setLocation((Object)yyValue, yyStart);
        }
        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.ExpLevel0.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pExpLevel0(final int yyStart) throws IOException {
    WhileyIColumn yyColumn = (WhileyIColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fExpLevel0) 
      yyColumn.chunk3.fExpLevel0 = pExpLevel0$1(yyStart);
    return yyColumn.chunk3.fExpLevel0;
  }

  /** Actually parse whiley.WhileyI.ExpLevel0. */
  private Result pExpLevel0$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Exp        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol1(yyStart);
    if (yyResult.hasValue("!")) {

      yyResult = pExpLevel0(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Exp v1 = yyResult.semanticValue();

        yyValue = new Not (v1);

        if (yyValue instanceof Object) {
          setLocation((Object)yyValue, yyStart);
        }
        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pSymbol1(yyStart);
    if (yyResult.hasValue("-")) {

      yyResult = pExpLevel0(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Exp v1 = yyResult.semanticValue();

        yyValue = new Neg (v1);

        if (yyValue instanceof Object) {
          setLocation((Object)yyValue, yyStart);
        }
        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 3.

    yyResult = pSymbol1(yyStart);
    if (yyResult.hasValue("(")) {

      yyResult = pExp(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Exp v1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol1(yyBase);
        if (yyResult.hasValue(")")) {

          yyValue = v1;

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("')' expected", yyBase);
        }
      }
    }

    // Alternative 4.

    yyResult = pSymbol1(yyStart);
    if (yyResult.hasValue("[")) {

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyResult = pExp(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Exp v1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol1(yyBase);
        if (yyResult.hasValue(";")) {

          yyResult = pExp(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Exp v2 = yyResult.semanticValue();

            yyBase   = yyResult.index;
            yyResult = pSymbol1(yyBase);
            if (yyResult.hasValue("]")) {

              yyValue = new ArrGen (v1, v2);

              if (yyValue instanceof Object) {
                setLocation((Object)yyValue, yyStart);
              }
              return yyResult.createValue(yyValue, yyError);
            } else {
              yyError = yyError.select("']' expected", yyBase);
            }
          }
        } else {
          yyError = yyError.select("';' expected", yyBase);
        }
      }

      // Nested alternative 2.

      yyResult = pArgList(yyChoice1);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        ArgList v1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol1(yyBase);
        if (yyResult.hasValue("]")) {

          yyValue = new ArrInit (v1);

          if (yyValue instanceof Object) {
            setLocation((Object)yyValue, yyStart);
          }
          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("']' expected", yyBase);
        }
      }
    }

    // Alternative 5.

    yyResult = pAssign(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Exp v1 = yyResult.semanticValue();

      yyValue = v1;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 6.

    yyResult = pLength(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Exp v1 = yyResult.semanticValue();

      yyValue = v1;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 7.

    yyResult = pQuantExp(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      QuantExp v1 = yyResult.semanticValue();

      yyValue = new QuantifierExp (v1);

      if (yyValue instanceof Object) {
        setLocation((Object)yyValue, yyStart);
      }
      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 8.

    yyResult = pLoc(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Loc v1 = yyResult.semanticValue();

      yyValue = new Use (v1);

      if (yyValue instanceof Object) {
        setLocation((Object)yyValue, yyStart);
      }
      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 9.

    yyResult = pLit(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Exp v1 = yyResult.semanticValue();

      yyValue = v1;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("exp expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.ExpLevel5.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pExpLevel5(final int yyStart) throws IOException {
    WhileyIColumn yyColumn = (WhileyIColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fExpLevel5) 
      yyColumn.chunk3.fExpLevel5 = pExpLevel5$1(yyStart);
    return yyColumn.chunk3.fExpLevel5;
  }

  /** Actually parse whiley.WhileyI.ExpLevel5. */
  private Result pExpLevel5$1(final int yyStart) throws IOException {
    Result     yyResult;
    Exp        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpLevel4(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Exp v1 = yyResult.semanticValue();

      yyResult = pExpLevel5$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Vector<Action<Exp>> v2 = yyResult.semanticValue();

        yyValue = ParserSupport.apply(v2, v1);

        if (yyValue instanceof Object) {
          setLocation((Object)yyValue, yyStart);
        }
        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal whiley.WhileyI.ExpLevel5$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpLevel5$$Star1(final int yyStart) throws IOException {
    WhileyIColumn yyColumn = (WhileyIColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fExpLevel5$$Star1) 
      yyColumn.chunk3.fExpLevel5$$Star1 = pExpLevel5$$Star1$1(yyStart);
    return yyColumn.chunk3.fExpLevel5$$Star1;
  }

  /** Actually parse whiley.WhileyI.ExpLevel5$$Star1. */
  private Result pExpLevel5$$Star1$1(final int yyStart) throws IOException {
    Result            yyResult;
    Vector<Action<Exp>> yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpLevel5Tail(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Action<Exp> v$el$1 = yyResult.semanticValue();

      yyResult = pExpLevel5$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Vector<Action<Exp>> v$2 = yyResult.semanticValue();

        yyValue = SVector.create(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = SVector.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.ExpLevel5Tail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpLevel5Tail(final int yyStart) throws IOException {
    Result      yyResult;
    Action<Exp> yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol2(yyStart);
    if (yyResult.hasValue("==")) {

      yyResult = pExpLevel4(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Exp v1 = yyResult.semanticValue();

        yyValue = new Action<Exp>() {
          public Exp run (Exp left) {
            EQ node = new EQ (left, v1);
            copyLocation(node, left);
            return node;
          };
        };

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pSymbol2(yyStart);
    if (yyResult.hasValue("!=")) {

      yyResult = pExpLevel4(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Exp v1 = yyResult.semanticValue();

        yyValue = new Action<Exp>() {
          public Exp run (Exp left) {
            NE node = new NE (left, v1);
            copyLocation(node, left);
            return node;
          };
        };

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("exp level5 tail expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.ExpLevel10.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pExpLevel10(final int yyStart) throws IOException {
    Result            yyResult;
    int               yyRepetition1;
    Vector<Action<Exp>> yyRepValue1;
    Exp               yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpLevel9(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Exp v1 = yyResult.semanticValue();

      yyRepetition1 = yyResult.index;
      yyRepValue1   = SVector.empty();
      while (true) {

        yyResult = pExpLevel10Tail(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          Action<Exp> v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = SVector.create(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v2.
        Vector<Action<Exp>> v2 = SVector.reverse(yyRepValue1);

        yyValue = ParserSupport.apply(v2, v1);

        if (yyValue instanceof Object) {
          setLocation((Object)yyValue, yyStart);
        }
        return new SemanticValue(yyValue, yyRepetition1, yyError);
      } // End scope for v2.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.ExpLevel10Tail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpLevel10Tail(final int yyStart) throws IOException {
    Result      yyResult;
    Action<Exp> yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol4(yyStart);
    if (yyResult.hasValue("<==>")) {

      yyResult = pExpLevel9(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Exp v1 = yyResult.semanticValue();

        yyValue = new Action<Exp>() {
          public Exp run (Exp left) {
            Iff node = new Iff (left, v1);
            copyLocation(node, left);
            return node;
          };
        };

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("exp level10 tail expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.ExpLevel1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pExpLevel1(final int yyStart) throws IOException {
    WhileyIColumn yyColumn = (WhileyIColumn)column(yyStart);
    if (null == yyColumn.chunk3) yyColumn.chunk3 = new Chunk3();
    if (null == yyColumn.chunk3.fExpLevel1) 
      yyColumn.chunk3.fExpLevel1 = pExpLevel1$1(yyStart);
    return yyColumn.chunk3.fExpLevel1;
  }

  /** Actually parse whiley.WhileyI.ExpLevel1. */
  private Result pExpLevel1$1(final int yyStart) throws IOException {
    Result     yyResult;
    Exp        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpLevel0(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Exp v1 = yyResult.semanticValue();

      yyResult = pExpLevel1$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Vector<Action<Exp>> v2 = yyResult.semanticValue();

        yyValue = ParserSupport.apply(v2, v1);

        if (yyValue instanceof Object) {
          setLocation((Object)yyValue, yyStart);
        }
        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal whiley.WhileyI.ExpLevel1$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpLevel1$$Star1(final int yyStart) throws IOException {
    WhileyIColumn yyColumn = (WhileyIColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fExpLevel1$$Star1) 
      yyColumn.chunk4.fExpLevel1$$Star1 = pExpLevel1$$Star1$1(yyStart);
    return yyColumn.chunk4.fExpLevel1$$Star1;
  }

  /** Actually parse whiley.WhileyI.ExpLevel1$$Star1. */
  private Result pExpLevel1$$Star1$1(final int yyStart) throws IOException {
    Result            yyResult;
    Vector<Action<Exp>> yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpLevel1Tail(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Action<Exp> v$el$1 = yyResult.semanticValue();

      yyResult = pExpLevel1$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Vector<Action<Exp>> v$2 = yyResult.semanticValue();

        yyValue = SVector.create(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = SVector.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.ExpLevel1Tail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpLevel1Tail(final int yyStart) throws IOException {
    Result      yyResult;
    int         yyBase;
    Action<Exp> yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol1(yyStart);
    if (yyResult.hasValue("*")) {

      yyResult = pExpLevel0(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Exp v1 = yyResult.semanticValue();

        yyValue = new Action<Exp>() {
          public Exp run (Exp left) {
            Mul node = new Mul (left, v1);
            copyLocation(node, left);
            return node;
          };
        };

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pSymbol1(yyStart);
    if (yyResult.hasValue("/")) {

      yyResult = pExpLevel0(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Exp v1 = yyResult.semanticValue();

        yyValue = new Action<Exp>() {
          public Exp run (Exp left) {
            Div node = new Div (left, v1);
            copyLocation(node, left);
            return node;
          };
        };

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 3.

    yyResult = pSymbol1(yyStart);
    if (yyResult.hasValue("%")) {

      yyResult = pExpLevel0(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Exp v1 = yyResult.semanticValue();

        yyValue = new Action<Exp>() {
          public Exp run (Exp left) {
            Rem node = new Rem (left, v1);
            copyLocation(node, left);
            return node;
          };
        };

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 4.

    yyResult = pSymbol1(yyStart);
    if (yyResult.hasValue("[")) {

      yyResult = pExpLevel0(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Exp v1 = yyResult.semanticValue();

        yyBase   = yyResult.index;
        yyResult = pSymbol1(yyBase);
        if (yyResult.hasValue("]")) {

          yyValue = new Action<Exp>() {
            public Exp run (Exp left) {
              ArrAccess node = new ArrAccess (left, v1);
              copyLocation(node, left);
              return node;
            };
          };

          return yyResult.createValue(yyValue, yyError);
        } else {
          yyError = yyError.select("']' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("exp level1 tail expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.ExpLevel6.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pExpLevel6(final int yyStart) throws IOException {
    WhileyIColumn yyColumn = (WhileyIColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fExpLevel6) 
      yyColumn.chunk4.fExpLevel6 = pExpLevel6$1(yyStart);
    return yyColumn.chunk4.fExpLevel6;
  }

  /** Actually parse whiley.WhileyI.ExpLevel6. */
  private Result pExpLevel6$1(final int yyStart) throws IOException {
    Result     yyResult;
    Exp        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpLevel5(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Exp v1 = yyResult.semanticValue();

      yyResult = pExpLevel6$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Vector<Action<Exp>> v2 = yyResult.semanticValue();

        yyValue = ParserSupport.apply(v2, v1);

        if (yyValue instanceof Object) {
          setLocation((Object)yyValue, yyStart);
        }
        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal whiley.WhileyI.ExpLevel6$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpLevel6$$Star1(final int yyStart) throws IOException {
    WhileyIColumn yyColumn = (WhileyIColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fExpLevel6$$Star1) 
      yyColumn.chunk4.fExpLevel6$$Star1 = pExpLevel6$$Star1$1(yyStart);
    return yyColumn.chunk4.fExpLevel6$$Star1;
  }

  /** Actually parse whiley.WhileyI.ExpLevel6$$Star1. */
  private Result pExpLevel6$$Star1$1(final int yyStart) throws IOException {
    Result            yyResult;
    Vector<Action<Exp>> yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpLevel6Tail(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Action<Exp> v$el$1 = yyResult.semanticValue();

      yyResult = pExpLevel6$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Vector<Action<Exp>> v$2 = yyResult.semanticValue();

        yyValue = SVector.create(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = SVector.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.ExpLevel6Tail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpLevel6Tail(final int yyStart) throws IOException {
    Result      yyResult;
    Action<Exp> yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol2(yyStart);
    if (yyResult.hasValue("&&")) {

      yyResult = pExpLevel5(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Exp v1 = yyResult.semanticValue();

        yyValue = new Action<Exp>() {
          public Exp run (Exp left) {
            And node = new And (left, v1);
            copyLocation(node, left);
            return node;
          };
        };

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pSymbol1(yyStart);
    if (yyResult.hasValue("&")) {

      yyResult = pExpLevel5(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Exp v1 = yyResult.semanticValue();

        yyValue = new Action<Exp>() {
          public Exp run (Exp left) {
            BitWiseAnd node = new BitWiseAnd (left, v1);
            copyLocation(node, left);
            return node;
          };
        };

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("exp level6 tail expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.ExpLevel9.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pExpLevel9(final int yyStart) throws IOException {
    WhileyIColumn yyColumn = (WhileyIColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fExpLevel9) 
      yyColumn.chunk4.fExpLevel9 = pExpLevel9$1(yyStart);
    return yyColumn.chunk4.fExpLevel9;
  }

  /** Actually parse whiley.WhileyI.ExpLevel9. */
  private Result pExpLevel9$1(final int yyStart) throws IOException {
    Result     yyResult;
    Exp        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpLevel8(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Exp v1 = yyResult.semanticValue();

      yyResult = pExpLevel9$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Vector<Action<Exp>> v2 = yyResult.semanticValue();

        yyValue = ParserSupport.apply(v2, v1);

        if (yyValue instanceof Object) {
          setLocation((Object)yyValue, yyStart);
        }
        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal whiley.WhileyI.ExpLevel9$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpLevel9$$Star1(final int yyStart) throws IOException {
    WhileyIColumn yyColumn = (WhileyIColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fExpLevel9$$Star1) 
      yyColumn.chunk4.fExpLevel9$$Star1 = pExpLevel9$$Star1$1(yyStart);
    return yyColumn.chunk4.fExpLevel9$$Star1;
  }

  /** Actually parse whiley.WhileyI.ExpLevel9$$Star1. */
  private Result pExpLevel9$$Star1$1(final int yyStart) throws IOException {
    Result            yyResult;
    Vector<Action<Exp>> yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpLevel9Tail(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Action<Exp> v$el$1 = yyResult.semanticValue();

      yyResult = pExpLevel9$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Vector<Action<Exp>> v$2 = yyResult.semanticValue();

        yyValue = SVector.create(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = SVector.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.ExpLevel9Tail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpLevel9Tail(final int yyStart) throws IOException {
    Result      yyResult;
    Action<Exp> yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol3(yyStart);
    if (yyResult.hasValue("==>")) {

      yyResult = pExpLevel8(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Exp v1 = yyResult.semanticValue();

        yyValue = new Action<Exp>() {
          public Exp run (Exp left) {
            Implies node = new Implies (left, v1);
            copyLocation(node, left);
            return node;
          };
        };

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("exp level9 tail expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.ExpLevel2.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pExpLevel2(final int yyStart) throws IOException {
    WhileyIColumn yyColumn = (WhileyIColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fExpLevel2) 
      yyColumn.chunk4.fExpLevel2 = pExpLevel2$1(yyStart);
    return yyColumn.chunk4.fExpLevel2;
  }

  /** Actually parse whiley.WhileyI.ExpLevel2. */
  private Result pExpLevel2$1(final int yyStart) throws IOException {
    Result     yyResult;
    Exp        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpLevel1(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Exp v1 = yyResult.semanticValue();

      yyResult = pExpLevel2$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Vector<Action<Exp>> v2 = yyResult.semanticValue();

        yyValue = ParserSupport.apply(v2, v1);

        if (yyValue instanceof Object) {
          setLocation((Object)yyValue, yyStart);
        }
        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal whiley.WhileyI.ExpLevel2$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpLevel2$$Star1(final int yyStart) throws IOException {
    WhileyIColumn yyColumn = (WhileyIColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fExpLevel2$$Star1) 
      yyColumn.chunk4.fExpLevel2$$Star1 = pExpLevel2$$Star1$1(yyStart);
    return yyColumn.chunk4.fExpLevel2$$Star1;
  }

  /** Actually parse whiley.WhileyI.ExpLevel2$$Star1. */
  private Result pExpLevel2$$Star1$1(final int yyStart) throws IOException {
    Result            yyResult;
    Vector<Action<Exp>> yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpLevel2Tail(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Action<Exp> v$el$1 = yyResult.semanticValue();

      yyResult = pExpLevel2$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Vector<Action<Exp>> v$2 = yyResult.semanticValue();

        yyValue = SVector.create(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = SVector.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.ExpLevel2Tail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpLevel2Tail(final int yyStart) throws IOException {
    Result      yyResult;
    Action<Exp> yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol1(yyStart);
    if (yyResult.hasValue("+")) {

      yyResult = pExpLevel1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Exp v1 = yyResult.semanticValue();

        yyValue = new Action<Exp>() {
          public Exp run (Exp left) {
            Add node = new Add (left, v1);
            copyLocation(node, left);
            return node;
          };
        };

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pSymbol1(yyStart);
    if (yyResult.hasValue("-")) {

      yyResult = pExpLevel1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Exp v1 = yyResult.semanticValue();

        yyValue = new Action<Exp>() {
          public Exp run (Exp left) {
            Sub node = new Sub (left, v1);
            copyLocation(node, left);
            return node;
          };
        };

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("exp level2 tail expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.ExpLevel7.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pExpLevel7(final int yyStart) throws IOException {
    WhileyIColumn yyColumn = (WhileyIColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fExpLevel7) 
      yyColumn.chunk4.fExpLevel7 = pExpLevel7$1(yyStart);
    return yyColumn.chunk4.fExpLevel7;
  }

  /** Actually parse whiley.WhileyI.ExpLevel7. */
  private Result pExpLevel7$1(final int yyStart) throws IOException {
    Result     yyResult;
    Exp        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpLevel6(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Exp v1 = yyResult.semanticValue();

      yyResult = pExpLevel7$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Vector<Action<Exp>> v2 = yyResult.semanticValue();

        yyValue = ParserSupport.apply(v2, v1);

        if (yyValue instanceof Object) {
          setLocation((Object)yyValue, yyStart);
        }
        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal whiley.WhileyI.ExpLevel7$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpLevel7$$Star1(final int yyStart) throws IOException {
    WhileyIColumn yyColumn = (WhileyIColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fExpLevel7$$Star1) 
      yyColumn.chunk4.fExpLevel7$$Star1 = pExpLevel7$$Star1$1(yyStart);
    return yyColumn.chunk4.fExpLevel7$$Star1;
  }

  /** Actually parse whiley.WhileyI.ExpLevel7$$Star1. */
  private Result pExpLevel7$$Star1$1(final int yyStart) throws IOException {
    Result            yyResult;
    Vector<Action<Exp>> yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpLevel7Tail(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Action<Exp> v$el$1 = yyResult.semanticValue();

      yyResult = pExpLevel7$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Vector<Action<Exp>> v$2 = yyResult.semanticValue();

        yyValue = SVector.create(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = SVector.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.ExpLevel7Tail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpLevel7Tail(final int yyStart) throws IOException {
    Result      yyResult;
    Action<Exp> yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol1(yyStart);
    if (yyResult.hasValue("^")) {

      yyResult = pExpLevel6(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Exp v1 = yyResult.semanticValue();

        yyValue = new Action<Exp>() {
          public Exp run (Exp left) {
            Xor node = new Xor (left, v1);
            copyLocation(node, left);
            return node;
          };
        };

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("exp level7 tail expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.ExpLevel3.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pExpLevel3(final int yyStart) throws IOException {
    WhileyIColumn yyColumn = (WhileyIColumn)column(yyStart);
    if (null == yyColumn.chunk4) yyColumn.chunk4 = new Chunk4();
    if (null == yyColumn.chunk4.fExpLevel3) 
      yyColumn.chunk4.fExpLevel3 = pExpLevel3$1(yyStart);
    return yyColumn.chunk4.fExpLevel3;
  }

  /** Actually parse whiley.WhileyI.ExpLevel3. */
  private Result pExpLevel3$1(final int yyStart) throws IOException {
    Result     yyResult;
    Exp        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpLevel2(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Exp v1 = yyResult.semanticValue();

      yyResult = pExpLevel3$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Vector<Action<Exp>> v2 = yyResult.semanticValue();

        yyValue = ParserSupport.apply(v2, v1);

        if (yyValue instanceof Object) {
          setLocation((Object)yyValue, yyStart);
        }
        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal whiley.WhileyI.ExpLevel3$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpLevel3$$Star1(final int yyStart) throws IOException {
    WhileyIColumn yyColumn = (WhileyIColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fExpLevel3$$Star1) 
      yyColumn.chunk5.fExpLevel3$$Star1 = pExpLevel3$$Star1$1(yyStart);
    return yyColumn.chunk5.fExpLevel3$$Star1;
  }

  /** Actually parse whiley.WhileyI.ExpLevel3$$Star1. */
  private Result pExpLevel3$$Star1$1(final int yyStart) throws IOException {
    Result            yyResult;
    Vector<Action<Exp>> yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpLevel3Tail(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Action<Exp> v$el$1 = yyResult.semanticValue();

      yyResult = pExpLevel3$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Vector<Action<Exp>> v$2 = yyResult.semanticValue();

        yyValue = SVector.create(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = SVector.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.ExpLevel3Tail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpLevel3Tail(final int yyStart) throws IOException {
    Result      yyResult;
    Action<Exp> yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol2(yyStart);
    if (yyResult.hasValue("<<")) {

      yyResult = pExpLevel2(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Exp v1 = yyResult.semanticValue();

        yyValue = new Action<Exp>() {
          public Exp run (Exp left) {
            Lsh node = new Lsh (left, v1);
            copyLocation(node, left);
            return node;
          };
        };

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pSymbol2(yyStart);
    if (yyResult.hasValue(">>")) {

      yyResult = pExpLevel2(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Exp v1 = yyResult.semanticValue();

        yyValue = new Action<Exp>() {
          public Exp run (Exp left) {
            ARsh node = new ARsh (left, v1);
            copyLocation(node, left);
            return node;
          };
        };

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("exp level3 tail expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.ExpLevel8.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pExpLevel8(final int yyStart) throws IOException {
    WhileyIColumn yyColumn = (WhileyIColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fExpLevel8) 
      yyColumn.chunk5.fExpLevel8 = pExpLevel8$1(yyStart);
    return yyColumn.chunk5.fExpLevel8;
  }

  /** Actually parse whiley.WhileyI.ExpLevel8. */
  private Result pExpLevel8$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Exp        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpLevel7(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Exp v1 = yyResult.semanticValue();

      final int yyChoice1 = yyResult.index;

      // Nested alternative 1.

      yyBase   = yyChoice1;
      yyResult = pSymbol2(yyBase);
      if (yyResult.hasValue("||")) {

        yyResult = pExpLevel7(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Exp v2 = yyResult.semanticValue();

          yyValue = new Or (v1, v2);

          if (yyValue instanceof Object) {
            setLocation((Object)yyValue, yyStart);
          }
          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("'||' expected", yyBase);
      }

      // Nested alternative 2.

      yyValue = v1;

      return new SemanticValue(yyValue, yyChoice1, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.ExpLevel4.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pExpLevel4(final int yyStart) throws IOException {
    WhileyIColumn yyColumn = (WhileyIColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fExpLevel4) 
      yyColumn.chunk5.fExpLevel4 = pExpLevel4$1(yyStart);
    return yyColumn.chunk5.fExpLevel4;
  }

  /** Actually parse whiley.WhileyI.ExpLevel4. */
  private Result pExpLevel4$1(final int yyStart) throws IOException {
    Result     yyResult;
    Exp        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpLevel3(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Exp v1 = yyResult.semanticValue();

      yyResult = pExpLevel4$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Vector<Action<Exp>> v2 = yyResult.semanticValue();

        yyValue = ParserSupport.apply(v2, v1);

        if (yyValue instanceof Object) {
          setLocation((Object)yyValue, yyStart);
        }
        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse synthetic nonterminal whiley.WhileyI.ExpLevel4$$Star1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpLevel4$$Star1(final int yyStart) throws IOException {
    WhileyIColumn yyColumn = (WhileyIColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fExpLevel4$$Star1) 
      yyColumn.chunk5.fExpLevel4$$Star1 = pExpLevel4$$Star1$1(yyStart);
    return yyColumn.chunk5.fExpLevel4$$Star1;
  }

  /** Actually parse whiley.WhileyI.ExpLevel4$$Star1. */
  private Result pExpLevel4$$Star1$1(final int yyStart) throws IOException {
    Result            yyResult;
    Vector<Action<Exp>> yyValue;
    ParseError        yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pExpLevel4Tail(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Action<Exp> v$el$1 = yyResult.semanticValue();

      yyResult = pExpLevel4$$Star1(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Vector<Action<Exp>> v$2 = yyResult.semanticValue();

        yyValue = SVector.create(v$el$1, v$2);

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyValue = SVector.empty();

    return new SemanticValue(yyValue, yyStart, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.ExpLevel4Tail.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pExpLevel4Tail(final int yyStart) throws IOException {
    Result      yyResult;
    Action<Exp> yyValue;
    ParseError  yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol1(yyStart);
    if (yyResult.hasValue("<")) {

      yyResult = pExpLevel3(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Exp v1 = yyResult.semanticValue();

        yyValue = new Action<Exp>() {
          public Exp run (Exp left) {
            LT node = new LT (left, v1);
            copyLocation(node, left);
            return node;
          };
        };

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 2.

    yyResult = pSymbol2(yyStart);
    if (yyResult.hasValue("<=")) {

      yyResult = pExpLevel3(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Exp v1 = yyResult.semanticValue();

        yyValue = new Action<Exp>() {
          public Exp run (Exp left) {
            LE node = new LE (left, v1);
            copyLocation(node, left);
            return node;
          };
        };

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 3.

    yyResult = pSymbol1(yyStart);
    if (yyResult.hasValue(">")) {

      yyResult = pExpLevel3(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Exp v1 = yyResult.semanticValue();

        yyValue = new Action<Exp>() {
          public Exp run (Exp left) {
            GT node = new GT (left, v1);
            copyLocation(node, left);
            return node;
          };
        };

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Alternative 4.

    yyResult = pSymbol2(yyStart);
    if (yyResult.hasValue(">=")) {

      yyResult = pExpLevel3(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        final Exp v1 = yyResult.semanticValue();

        yyValue = new Action<Exp>() {
          public Exp run (Exp left) {
            GE node = new GE (left, v1);
            copyLocation(node, left);
            return node;
          };
        };

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("exp level4 tail expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.Spacing.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pSpacing(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    int        yyRepetition1;
    int        yyRepetition2;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    while (true) {

      final int yyChoice1 = yyRepetition1;

      // Nested alternative 1.

      yyC = character(yyChoice1);
      if (-1 != yyC) {
        yyIndex = yyChoice1 + 1;

        switch (yyC) {
        case ' ':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '\t':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '\f':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '\r':
          {
            final int yyChoice2 = yyIndex;

            // Nested alternative 1.

            yyC = character(yyChoice2);
            if ('\n' == yyC) {
              yyIndex = yyChoice2 + 1;

              yyRepetition1 = yyIndex;
              continue;
            }

            // Nested alternative 2.

            yyRepetition1 = yyChoice2;
            continue;
          }

        case '\n':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '/':
          {
            yyC = character(yyIndex);
            if (-1 != yyC) {
              yyIndex = yyIndex + 1;
              if ('/' == yyC) {

                yyRepetition2 = yyIndex;
                while (true) {

                  yyPredMatched = false;

                  yyPredResult = pEOL(yyRepetition2);
                  if (yyPredResult.hasValue()) {

                    yyPredMatched = true;
                  }

                  if (! yyPredMatched) {

                    yyC = character(yyRepetition2);
                    if (-1 != yyC) {
                      yyIndex = yyRepetition2 + 1;

                      yyRepetition2 = yyIndex;
                      continue;
                    }
                  } else {
                    yyError = yyError.select("spacing expected", yyStart);
                  }
                  break;
                }

                final int yyChoice2 = yyRepetition2;

                // Nested alternative 1.

                yyC = character(yyChoice2);
                if (-1 != yyC) {
                  yyIndex = yyChoice2 + 1;

                  switch (yyC) {
                  case '\r':
                    {
                      final int yyChoice3 = yyIndex;

                      // Nested alternative 1.

                      yyC = character(yyChoice3);
                      if ('\n' == yyC) {
                        yyIndex = yyChoice3 + 1;

                        yyRepetition1 = yyIndex;
                        continue;
                      }

                      // Nested alternative 2.

                      yyRepetition1 = yyChoice3;
                      continue;
                    }

                  case '\n':
                    {
                      yyRepetition1 = yyIndex;
                      continue;
                    }

                  default:
                    /* No match. */
                  }
                }

                // Nested alternative 2.

                yyPredMatched = false;

                yyC = character(yyChoice2);
                if (-1 != yyC) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyRepetition1 = yyChoice2;
                  continue;
                } else {
                  yyError = yyError.select("spacing expected", yyStart);
                }
              }
            }
          }
          break;

        default:
          /* No match. */
        }
      }

      // Nested alternative 2.

      yyResult = pMLComment(yyChoice1);
      yyError  = yyResult.select(yyError, yyRepetition1);
      if (yyResult.hasValue()) {

        yyRepetition1 = yyResult.index;
        continue;
      }
      break;
    }

    yyValue = null;

    return new SemanticValue(yyValue, yyRepetition1, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.Space.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pSpace(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case ' ':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\t':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\f':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\r':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if ('\n' == yyC) {
            yyIndex = yyChoice1 + 1;

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          }

          // Nested alternative 2.

          yyValue = null;

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '\n':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("space expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.EOL.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pEOL(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\r':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if ('\n' == yyC) {
            yyIndex = yyChoice1 + 1;

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          }

          // Nested alternative 2.

          yyValue = null;

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '\n':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("EOL expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.Comment.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pComment(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    int        yyRepetition1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('/' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('/' == yyC) {
        yyIndex = yyIndex + 1;

        yyRepetition1 = yyIndex;
        while (true) {

          yyPredMatched = false;

          yyPredResult = pEOL(yyRepetition1);
          if (yyPredResult.hasValue()) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyC = character(yyRepetition1);
            if (-1 != yyC) {
              yyIndex = yyRepetition1 + 1;

              yyRepetition1 = yyIndex;
              continue;
            }
          } else {
            yyError = yyError.select("comment expected", yyStart);
          }
          break;
        }

        final int yyChoice1 = yyRepetition1;

        // Nested alternative 1.

        yyC = character(yyChoice1);
        if (-1 != yyC) {
          yyIndex = yyChoice1 + 1;

          switch (yyC) {
          case '\r':
            {
              final int yyChoice2 = yyIndex;

              // Nested alternative 1.

              yyC = character(yyChoice2);
              if ('\n' == yyC) {
                yyIndex = yyChoice2 + 1;

                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

              // Nested alternative 2.

              yyValue = null;

              return new SemanticValue(yyValue, yyChoice2, yyError);
            }

          case '\n':
            {
              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }

          default:
            /* No match. */
          }
        }

        // Nested alternative 2.

        yyPredMatched = false;

        yyC = character(yyChoice1);
        if (-1 != yyC) {

          yyPredMatched = true;
        }

        if (! yyPredMatched) {

          yyValue = null;

          return new SemanticValue(yyValue, yyChoice1, yyError);
        } else {
          yyError = yyError.select("comment expected", yyStart);
        }
      }
    }

    // Alternative 2.

    yyResult = pMLComment(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("comment expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.SLComment.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pSLComment(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    int        yyRepetition1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('/' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('/' == yyC) {
        yyIndex = yyIndex + 1;

        yyRepetition1 = yyIndex;
        while (true) {

          yyPredMatched = false;

          yyPredResult = pEOL(yyRepetition1);
          if (yyPredResult.hasValue()) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyC = character(yyRepetition1);
            if (-1 != yyC) {
              yyIndex = yyRepetition1 + 1;

              yyRepetition1 = yyIndex;
              continue;
            }
          } else {
            yyError = yyError.select("s l comment expected", yyStart);
          }
          break;
        }

        final int yyChoice1 = yyRepetition1;

        // Nested alternative 1.

        yyC = character(yyChoice1);
        if (-1 != yyC) {
          yyIndex = yyChoice1 + 1;

          switch (yyC) {
          case '\r':
            {
              final int yyChoice2 = yyIndex;

              // Nested alternative 1.

              yyC = character(yyChoice2);
              if ('\n' == yyC) {
                yyIndex = yyChoice2 + 1;

                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

              // Nested alternative 2.

              yyValue = null;

              return new SemanticValue(yyValue, yyChoice2, yyError);
            }

          case '\n':
            {
              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }

          default:
            /* No match. */
          }
        }

        // Nested alternative 2.

        yyPredMatched = false;

        yyC = character(yyChoice1);
        if (-1 != yyC) {

          yyPredMatched = true;
        }

        if (! yyPredMatched) {

          yyValue = null;

          return new SemanticValue(yyValue, yyChoice1, yyError);
        } else {
          yyError = yyError.select("s l comment expected", yyStart);
        }
      }
    }

    // Done.
    yyError = yyError.select("s l comment expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.MLComment.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pMLComment(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyPredIndex;
    boolean    yyPredMatched;
    int        yyBase;
    int        yyRepetition1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('/' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('*' == yyC) {
        yyIndex = yyIndex + 1;

        yyRepetition1 = yyIndex;
        while (true) {

          final int yyChoice1 = yyRepetition1;

          // Nested alternative 1.

          yyResult = pMLComment(yyChoice1);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {

            yyRepetition1 = yyResult.index;
            continue;
          }

          // Nested alternative 2.

          yyPredMatched = false;

          yyC = character(yyChoice1);
          if ('*' == yyC) {
            yyPredIndex = yyChoice1 + 1;

            yyC = character(yyPredIndex);
            if ('/' == yyC) {

              yyPredMatched = true;
            }
          }

          if (! yyPredMatched) {

            yyC = character(yyChoice1);
            if (-1 != yyC) {
              yyIndex = yyChoice1 + 1;

              yyRepetition1 = yyIndex;
              continue;
            }
          } else {
            yyError = yyError.select("m l comment expected", yyStart);
          }
          break;
        }

        yyBase = yyRepetition1;
        yyC    = character(yyBase);
        if ('*' == yyC) {
          yyIndex = yyRepetition1 + 1;

          yyC = character(yyIndex);
          if ('/' == yyC) {
            yyIndex = yyIndex + 1;

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("'*/' expected", yyBase);
          }
        } else {
          yyError = yyError.select("'*/' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("m l comment expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.Identifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pIdentifier(final int yyStart) throws IOException {
    WhileyIColumn yyColumn = (WhileyIColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fIdentifier) 
      yyColumn.chunk5.fIdentifier = pIdentifier$1(yyStart);
    return yyColumn.chunk5.fIdentifier;
  }

  /** Actually parse whiley.WhileyI.Identifier. */
  private Result pIdentifier$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      if (! contains (KEYWORDS, yyValue)) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("identifier expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.Word.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pWord(final int yyStart) throws IOException {
    WhileyIColumn yyColumn = (WhileyIColumn)column(yyStart);
    if (null == yyColumn.chunk5) yyColumn.chunk5 = new Chunk5();
    if (null == yyColumn.chunk5.fWord) 
      yyColumn.chunk5.fWord = pWord$1(yyStart);
    return yyColumn.chunk5.fWord;
  }

  /** Actually parse whiley.WhileyI.Word. */
  private Result pWord$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWordCharacters(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.WordCharacters.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pWordCharacters(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      char h = (char)yyC;

      if (Character.isJavaIdentifierStart (h)) {

        yyRepetition1 = yyIndex;
        while (true) {

          yyC = character(yyRepetition1);
          if (-1 != yyC) {
            yyIndex = yyRepetition1 + 1;
            char t = (char)yyC;

            if (Character.isJavaIdentifierPart (t)) {

              yyRepetition1 = yyIndex;
              continue;
            }
          }
          break;
        }

        yyValue = difference(yyStart, yyRepetition1);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      }
    }

    // Done.
    yyError = yyError.select("word characters expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.EOF.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pEOF(final int yyStart) throws IOException {
    int        yyC;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyC = character(yyStart);
    if (-1 != yyC) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyValue = null;

      return new SemanticValue(yyValue, yyStart, yyError);
    } else {
      yyError = yyError.select("EOF expected", yyStart);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
  * Drop the current path off string when it occurs at the beginning.
  */
  public String dropCurrentPath (String string) {
    int index = 0;
    int stringlen = string.length ();
    String prefix = System.getProperty ("user.dir");
    int prefixlen = prefix.length ();
    while ((index < stringlen) && (index < prefixlen) && (string.charAt (index) == prefix.charAt (index))) {
      index++;
    }
    if ((index != 0) && (string.charAt (index) == java.io.File.separatorChar)) {
      index++;
    }
    return string.substring (index);
  }
  
  /**
  * Format a Rats! parser error message according to Scala compiler
  * conventions for better compatibility with error processors.
  */
  public String formatParseError (ParseError error, Boolean showCoord) throws IOException {
    StringBuilder buf = new StringBuilder ();
    
    if (error.index == -1) {
      buf.append (error.msg);
    } else {
      Location loc = location (error.index);
      if (showCoord) {
        String filename = loc.file;
        buf.append (filename);
        buf.append (':');
        buf.append (loc.line);
        buf.append (": ");
      }
      
      buf.append (error.msg);
      buf.append ("\n");
      
      String line = lineAt (error.index);
      buf.append (line);
      buf.append ('\n');
      for (int i = 1; i < loc.column; i++) buf.append (' ');
      buf.append ("^");
    }
    
    return buf.toString ();
  }
  
  static {
    add (KEYWORDS, new String[] {
      "all", "assert", "assume", "bool", "break", "byte", "case", "const",
      "continue", "debug", "default", "do", "else", "ensures", "export",
      "fail", "false", "from", "function", "if", "import", "in", "int",
      "is", "method", "native", "no", "null", "package", "private", "public",
      "requires", "return", "skip", "some", "switch", "true", "type",
      "where", "while"
    });
  }

  // =========================================================================

  /**
   * Add the specified values to the specified set.
   *
   * @param set The set.
   * @param values The new values.
   */
  protected static final <T> void add(Set<T> set, T[] values) {
    for (T v : values) set.add(v);
  }

  /**
   * Check whether the specified set contains the specified value.
   *
   * @param set The set.
   * @param value The value.
   * @return <code>true</code> if the set contains the value.
   */
  protected static final <T> boolean contains(Set<T> set, T value) {
    return set.contains(value);
  }

}
