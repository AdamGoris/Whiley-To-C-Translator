// AUTOMATICALLY GENERATED by sbt-rats - EDIT AT YOUR OWN RISK

package whiley

import whiley.CISyntax._
import org.bitbucket.inkytonik.kiama.output.{PrettyPrinter => PP, ParenPrettyPrinter => PPP}
import org.bitbucket.inkytonik.kiama.output.PrettyPrinterTypes.{Document, Width}

trait CIPrettyPrinter extends PP with PPP {

    
    def show (astNode : ASTNode, w : Width = defaultWidth) : String =
        format (astNode, w).layout
    
    def format (astNode : ASTNode, w : Width = defaultWidth) : Document =
        pretty (group (toDoc (astNode)), w)
    
    def toDoc (astNode : ASTNode) : Doc =
        astNode match {
            case v @ Program (v1) =>
                emptyDoc <> ssep (v1.map (toDoc), emptyDoc) <> emptyDoc 
            case v @ DeclAsgnC (v1, v2, v3) =>
                line <> toDoc (v1) <> toDoc (v2) <> text ("=") <> toDoc (v3) <> text (";") 
            case v @ DeclC (v1, v2) =>
                line <> toDoc (v1) <> toDoc (v2) <> text (";") 
            case v @ AsgnC (v1) =>
                line <> toDoc (v1) 
            case v @ IfC (v1, v2) =>
                line <> text ("if") <> space <> text ("(") <> toDoc (v1) <> text (")") <> text ("{") <> nest (ssep (v2.map (toDoc), emptyDoc)) <> line <> text ("}") 
            case v @ SwitchC (v1, v2) =>
                line <> text ("switch") <> space <> text ("(") <> toDoc (v1) <> text (")") <> text ("{") <> nest (ssep (v2.map (toDoc), emptyDoc)) <> line <> text ("}") 
            case v @ WhileC (v1, v2) =>
                line <> text ("while") <> space <> text ("(") <> toDoc (v1) <> text (")") <> text ("{") <> nest (ssep (v2.map (toDoc), emptyDoc)) <> line <> text ("}") 
            case v @ DoWhileC (v1, v2) =>
                line <> text ("do") <> space <> text ("{") <> nest (ssep (v1.map (toDoc), emptyDoc)) <> line <> text ("}") <> text ("while") <> space <> text ("(") <> toDoc (v2) <> text (")") 
            case v @ ForC (v1, v2, v3, v4, v5) =>
                line <> text ("for") <> space <> text ("(") <> toDoc (v1) <> toDoc (v2) <> text ("=") <> toDoc (v3) <> text (";") <> toDoc (v4) <> text (";") <> toDoc (v5) <> text (")") 
            case v @ FunctionDeclC (v1, v2, v3, v4) =>
                line <> toDoc (v1) <> toDoc (v2) <> text ("(") <> toDoc (v3) <> text (")") <> text ("{") <> nest (ssep (v4.map (toDoc), emptyDoc)) <> line <> text ("}") 
            case v @ ReturnC (v1) =>
                line <> text ("return") <> space <> toDoc (v1) 
            case v @ BreakC () =>
                line <> text ("break") <> space 
            case v @ CharTypeC () =>
                text ("char") <> space 
            case v @ UnsgnCharTypeC () =>
                text ("unsigned char") <> space 
            case v @ SgnCharTypeC () =>
                text ("signed char") <> space 
            case v @ IntTypeC () =>
                text ("int") <> space 
            case v @ UnsgnIntTypeC () =>
                text ("unsigned int") <> space 
            case v @ ShortTypeC () =>
                text ("short") <> space 
            case v @ UnsgnShortTypeC () =>
                text ("unsigned short") <> space 
            case v @ LongTypeC () =>
                text ("long") <> space 
            case v @ UnsgnLongTypeC () =>
                text ("unsigned long") <> space 
            case v @ FloatTypeC () =>
                text ("float") <> space 
            case v @ DoubleTypeC () =>
                text ("double") <> space 
            case v @ LongDoubleTypeC () =>
                text ("long double") <> space 
            case v @ VoidTypeC () =>
                text ("void") <> space                    
            case v : Exp =>
                toParenDoc (v)    
            case v @ CaseStmC (v1, v2) =>
                text ("case") <> space <> toDoc (v1) <> text (":") <> nest (ssep (v2.map (toDoc), emptyDoc)) <> line 
            case v @ ParametersC (v1, v2, v3) =>
                toDoc (v1) <> toDoc (v2) <> ssep (v3.map (toDoc), emptyDoc)    
            case v @ NullLiteralC () =>
                text ("NULL") <> space   
            case v @ CharacterLiteralC (v1) =>
                text ("'") <> space <> value (v1) <> text ("'") <> space     
            case v @ Loc (v1) =>
                value (v1)  
            case v @ CommTypeLoc (v1, v2) =>
                text (",") <> toDoc (v1) <> toDoc (v2)
        }
    
    override def toParenDoc (astNode : org.bitbucket.inkytonik.kiama.output.PrettyExpression) : Doc =
        astNode match {
            case v @ EQ (v1, v2) =>
                recursiveToDoc (v, v1, org.bitbucket.inkytonik.kiama.output.LeftAssoc) <> space <> text ("==") <> space <> recursiveToDoc (v, v2, org.bitbucket.inkytonik.kiama.output.RightAssoc) 
            case v @ NE (v1, v2) =>
                recursiveToDoc (v, v1, org.bitbucket.inkytonik.kiama.output.LeftAssoc) <> space <> text ("!=") <> space <> recursiveToDoc (v, v2, org.bitbucket.inkytonik.kiama.output.RightAssoc) 
            case v @ LT (v1, v2) =>
                recursiveToDoc (v, v1, org.bitbucket.inkytonik.kiama.output.LeftAssoc) <> space <> text ("<") <> space <> recursiveToDoc (v, v2, org.bitbucket.inkytonik.kiama.output.RightAssoc) 
            case v @ LE (v1, v2) =>
                recursiveToDoc (v, v1, org.bitbucket.inkytonik.kiama.output.LeftAssoc) <> space <> text ("<=") <> space <> recursiveToDoc (v, v2, org.bitbucket.inkytonik.kiama.output.RightAssoc) 
            case v @ GT (v1, v2) =>
                recursiveToDoc (v, v1, org.bitbucket.inkytonik.kiama.output.LeftAssoc) <> space <> text (">") <> space <> recursiveToDoc (v, v2, org.bitbucket.inkytonik.kiama.output.RightAssoc) 
            case v @ GE (v1, v2) =>
                recursiveToDoc (v, v1, org.bitbucket.inkytonik.kiama.output.LeftAssoc) <> space <> text (">=") <> space <> recursiveToDoc (v, v2, org.bitbucket.inkytonik.kiama.output.RightAssoc) 
            case v @ Lsh (v1, v2) =>
                recursiveToDoc (v, v1, org.bitbucket.inkytonik.kiama.output.LeftAssoc) <> space <> text ("<<") <> space <> recursiveToDoc (v, v2, org.bitbucket.inkytonik.kiama.output.RightAssoc) 
            case v @ ARsh (v1, v2) =>
                recursiveToDoc (v, v1, org.bitbucket.inkytonik.kiama.output.LeftAssoc) <> space <> text (">>") <> space <> recursiveToDoc (v, v2, org.bitbucket.inkytonik.kiama.output.RightAssoc) 
            case v @ Add (v1, v2) =>
                recursiveToDoc (v, v1, org.bitbucket.inkytonik.kiama.output.LeftAssoc) <> space <> text ("+") <> space <> recursiveToDoc (v, v2, org.bitbucket.inkytonik.kiama.output.RightAssoc) 
            case v @ Sub (v1, v2) =>
                recursiveToDoc (v, v1, org.bitbucket.inkytonik.kiama.output.LeftAssoc) <> space <> text ("-") <> space <> recursiveToDoc (v, v2, org.bitbucket.inkytonik.kiama.output.RightAssoc) 
            case v @ Mul (v1, v2) =>
                recursiveToDoc (v, v1, org.bitbucket.inkytonik.kiama.output.LeftAssoc) <> space <> text ("*") <> space <> recursiveToDoc (v, v2, org.bitbucket.inkytonik.kiama.output.RightAssoc) 
            case v @ Div (v1, v2) =>
                recursiveToDoc (v, v1, org.bitbucket.inkytonik.kiama.output.LeftAssoc) <> space <> text ("/") <> space <> recursiveToDoc (v, v2, org.bitbucket.inkytonik.kiama.output.RightAssoc) 
            case v @ Rem (v1, v2) =>
                recursiveToDoc (v, v1, org.bitbucket.inkytonik.kiama.output.LeftAssoc) <> space <> text ("%") <> space <> recursiveToDoc (v, v2, org.bitbucket.inkytonik.kiama.output.RightAssoc) 
            case v @ Not (v1) =>
                text ("!") <> recursiveToDoc (v, v1, org.bitbucket.inkytonik.kiama.output.RightAssoc) 
            case v @ Neg (v1) =>
                text ("-") <> recursiveToDoc (v, v1, org.bitbucket.inkytonik.kiama.output.RightAssoc) 
            case v @ Incr (v1) =>
                toDoc (v1) 
            case v @ Decr (v1) =>
                toDoc (v1) 
            case v @ Use (v1) =>
                toDoc (v1) 
            case v @ Assign (v1, v2) =>
                toDoc (v1) <> space <> text ("=") <> toDoc (v2) <> text (";") 
            case v @ Increment (v1) =>
                toDoc (v1) <> text ("++") <> space 
            case v @ Decrement (v1) =>
                toDoc (v1) <> text ("--") <> space 
            case v @ NullLitC (v1) =>
                toDoc (v1) 
            case v @ CharLitC (v1) =>
                toDoc (v1) 
            case v @ IntLitC (v1) =>
                value (v1)
            case _ =>
                super.toParenDoc (astNode)
        }

}

object CIPrettyPrinter extends CIPrettyPrinter

