// ===========================================================================
// This file has been generated by
// Rats! Parser Generator, version 2.4.0,
// (C) 2004-2014 Robert Grimm,
// on Saturday, 17 August 2019 at 2:49:26 PM.
// Edit at your own risk.
// ===========================================================================

package whiley;

import java.io.Reader;
import java.io.IOException;

import java.util.HashSet;
import java.util.Set;

import xtc.util.Pair;

import xtc.tree.Locatable;

import xtc.parser.ParserBase;
import xtc.parser.Column;
import xtc.parser.Result;
import xtc.parser.SemanticValue;
import xtc.parser.ParseError;

import whiley.WhileyISyntax.*;

import sbtrats.Action;
import xtc.tree.Location;

/**
 * Packrat parser for grammar <code>whiley.WhileyI</code>.
 *
 * <p />This class has been generated by the <i>Rats!</i> parser
 * generator, version 2.4.0, (C) 2004-2014 Robert Grimm.
 */
public final class WhileyI extends ParserBase {

  /** The KEYWORDS set. */
  public static final Set<String> KEYWORDS = new HashSet<String>();

  // =========================================================================

  /** Memoization table column. */
  static final class WhileyIColumn extends Column {
    Result fSymbol1;
    Result fExp;
    Result fAssign;
    Result fLoc;
    Result fIdentifier;
    Result fWord;
  }

  // =========================================================================

  /**
   * Create a new packrat parser.
   *
   * @param reader The reader.
   * @param file The file name.
   */
  public WhileyI(final Reader reader, final String file) {
    super(reader, file);
  }

  /**
   * Create a new packrat parser.
   *
   * @param reader The file reader.
   * @param file The file name.
   * @param size The file size.
   */
  public WhileyI(final Reader reader, final String file, final int size) {
    super(reader, file, size);
  }

  // =========================================================================

  protected Column newColumn() {
    return new WhileyIColumn();
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.Symbol1.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSymbol1(final int yyStart) throws IOException {
    WhileyIColumn yyColumn = (WhileyIColumn)column(yyStart);
    if (null == yyColumn.fSymbol1) yyColumn.fSymbol1 = pSymbol1$1(yyStart);
    return yyColumn.fSymbol1;
  }

  /** Actually parse whiley.WhileyI.Symbol1. */
  private Result pSymbol1$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSymbol1Alts(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.Symbol1Alts.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  private Result pSymbol1Alts(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '=':
        {
          yyValue = "=";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '0':
        {
          yyValue = "0";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("symbol1 alts expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.Program.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pProgram(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyRepetition1;
    Pair<Stm>  yyRepValue1;
    Program    yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pSpacing(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyRepetition1 = yyResult.index;
      yyRepValue1   = Pair.empty();
      while (true) {

        yyResult = pStm(yyRepetition1);
        yyError  = yyResult.select(yyError, yyRepetition1);
        if (yyResult.hasValue()) {
          Stm v$el$1 = yyResult.semanticValue();

          yyRepetition1 = yyResult.index;
          yyRepValue1   = new Pair<Stm>(v$el$1, yyRepValue1);
          continue;
        }
        break;
      }
      { // Start scope for v1.
        Pair<Stm> v1 = yyRepValue1.reverse();

        yyResult = pEOF(yyRepetition1);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {

          yyValue = new Program (v1);

          if (yyValue instanceof Locatable) {
            setLocation((Locatable)yyValue, yyStart);
          }
          return yyResult.createValue(yyValue, yyError);
        }
      } // End scope for v1.
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.Stm.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pStm(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Stm        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pType(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Type v1 = yyResult.semanticValue();

      yyResult = pLoc(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {
        Loc v2 = yyResult.semanticValue();

        final int yyChoice1 = yyResult.index;

        // Nested alternative 1.

        yyBase   = yyChoice1;
        yyResult = pSymbol1(yyBase);
        if (yyResult.hasValue("=")) {

          yyResult = pExp(yyResult.index);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {
            Exp v3 = yyResult.semanticValue();

            yyValue = new DeclAsgn (v1, v2, v3);

            if (yyValue instanceof Locatable) {
              setLocation((Locatable)yyValue, yyStart);
            }
            return yyResult.createValue(yyValue, yyError);
          }
        } else {
          yyError = yyError.select("'=' expected", yyBase);
        }

        // Nested alternative 2.

        yyValue = new Decl (v1, v2);

        if (yyValue instanceof Locatable) {
          setLocation((Locatable)yyValue, yyStart);
        }
        return new SemanticValue(yyValue, yyChoice1, yyError);
      }
    }

    // Alternative 2.

    yyResult = pAssign(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Exp v1 = yyResult.semanticValue();

      yyValue = new AsgnStm (v1);

      if (yyValue instanceof Locatable) {
        setLocation((Locatable)yyValue, yyStart);
      }
      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.Type.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pType(final int yyStart) throws IOException {
    Result     yyResult;
    Type       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("int")) {

      yyValue = new IntType ();

      if (yyValue instanceof Locatable) {
        setLocation((Locatable)yyValue, yyStart);
      }
      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("byte")) {

      yyValue = new ByteType ();

      if (yyValue instanceof Locatable) {
        setLocation((Locatable)yyValue, yyStart);
      }
      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("bool")) {

      yyValue = new BoolType ();

      if (yyValue instanceof Locatable) {
        setLocation((Locatable)yyValue, yyStart);
      }
      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("type expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.Exp.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pExp(final int yyStart) throws IOException {
    WhileyIColumn yyColumn = (WhileyIColumn)column(yyStart);
    if (null == yyColumn.fExp) yyColumn.fExp = pExp$1(yyStart);
    return yyColumn.fExp;
  }

  /** Actually parse whiley.WhileyI.Exp. */
  private Result pExp$1(final int yyStart) throws IOException {
    Result     yyResult;
    Exp        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLit(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Exp v1 = yyResult.semanticValue();

      yyValue = v1;

      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pLoc(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Loc v1 = yyResult.semanticValue();

      yyValue = new Use (v1);

      if (yyValue instanceof Locatable) {
        setLocation((Locatable)yyValue, yyStart);
      }
      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 3.

    yyResult = pAssign(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Exp v1 = yyResult.semanticValue();

      yyValue = v1;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.Assign.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pAssign(final int yyStart) throws IOException {
    WhileyIColumn yyColumn = (WhileyIColumn)column(yyStart);
    if (null == yyColumn.fAssign) yyColumn.fAssign = pAssign$1(yyStart);
    return yyColumn.fAssign;
  }

  /** Actually parse whiley.WhileyI.Assign. */
  private Result pAssign$1(final int yyStart) throws IOException {
    Result     yyResult;
    int        yyBase;
    Exp        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pLoc(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Loc v1 = yyResult.semanticValue();

      yyBase   = yyResult.index;
      yyResult = pSymbol1(yyBase);
      if (yyResult.hasValue("=")) {

        yyResult = pExp(yyResult.index);
        yyError  = yyResult.select(yyError);
        if (yyResult.hasValue()) {
          Exp v2 = yyResult.semanticValue();

          yyValue = new Assign (v1, v2);

          if (yyValue instanceof Locatable) {
            setLocation((Locatable)yyValue, yyStart);
          }
          return yyResult.createValue(yyValue, yyError);
        }
      } else {
        yyError = yyError.select("'=' expected", yyBase);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.Lit.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pLit(final int yyStart) throws IOException {
    Result     yyResult;
    Exp        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIntegerLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v1 = yyResult.semanticValue();

      yyValue = new IntLit (Integer.parseInt (v1));

      if (yyValue instanceof Locatable) {
        setLocation((Locatable)yyValue, yyStart);
      }
      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pBooleanLiteral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      Exp v1 = yyResult.semanticValue();

      yyValue = v1;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.IntegerLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pIntegerLiteral(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pDecimalNumeral(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.IntegerLiteralForm.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pIntegerLiteralForm(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '0':
        {
          yyValue = "0";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        {
          yyResult = pDigits(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = difference(yyStart, yyResult.index);

            return yyResult.createValue(yyValue, yyError);
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("integer literal form expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.DecimalNumeral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pDecimalNumeral(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '0':
        {
          yyValue = "0";

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        {
          yyResult = pDigits(yyIndex);
          yyError  = yyResult.select(yyError);
          if (yyResult.hasValue()) {

            yyValue = difference(yyStart, yyResult.index);

            return yyResult.createValue(yyValue, yyError);
          }
        }
        break;

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("decimal numeral expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.Digits.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pDigits(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    while (true) {

      yyC = character(yyRepetition1);
      if (-1 != yyC) {
        yyIndex = yyRepetition1 + 1;

        switch (yyC) {
        case '0':
        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        default:
          /* No match. */
        }
      }
      break;
    }

    yyValue = difference(yyStart, yyRepetition1);

    return new SemanticValue(yyValue, yyRepetition1, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.NonZeroDigit.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pNonZeroDigit(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        {
          yyValue = difference(yyStart, yyIndex);

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("non zero digit expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.Digit.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pDigit(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '0':
      case '1':
      case '2':
      case '3':
      case '4':
      case '5':
      case '6':
      case '7':
      case '8':
      case '9':
        {
          yyValue = difference(yyStart, yyIndex);

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("digit expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.BooleanLiteral.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pBooleanLiteral(final int yyStart) throws IOException {
    Result     yyResult;
    Exp        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("false")) {

      yyValue = new False ();

      if (yyValue instanceof Locatable) {
        setLocation((Locatable)yyValue, yyStart);
      }
      return yyResult.createValue(yyValue, yyError);
    }

    // Alternative 2.

    yyResult = pWord(yyStart);
    if (yyResult.hasValue("true")) {

      yyValue = new True ();

      if (yyValue instanceof Locatable) {
        setLocation((Locatable)yyValue, yyStart);
      }
      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("boolean literal expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.Loc.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pLoc(final int yyStart) throws IOException {
    WhileyIColumn yyColumn = (WhileyIColumn)column(yyStart);
    if (null == yyColumn.fLoc) yyColumn.fLoc = pLoc$1(yyStart);
    return yyColumn.fLoc;
  }

  /** Actually parse whiley.WhileyI.Loc. */
  private Result pLoc$1(final int yyStart) throws IOException {
    Result     yyResult;
    Loc        yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      String v1 = yyResult.semanticValue();

      yyValue = new Loc (v1);

      if (yyValue instanceof Locatable) {
        setLocation((Locatable)yyValue, yyStart);
      }
      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.Lab.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pLab(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pIdentifier(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.Spacing.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pSpacing(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    int        yyRepetition1;
    int        yyRepetition2;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyRepetition1 = yyStart;
    while (true) {

      final int yyChoice1 = yyRepetition1;

      // Nested alternative 1.

      yyC = character(yyChoice1);
      if (-1 != yyC) {
        yyIndex = yyChoice1 + 1;

        switch (yyC) {
        case ' ':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '\t':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '\f':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '\r':
          {
            final int yyChoice2 = yyIndex;

            // Nested alternative 1.

            yyC = character(yyChoice2);
            if ('\n' == yyC) {
              yyIndex = yyChoice2 + 1;

              yyRepetition1 = yyIndex;
              continue;
            }

            // Nested alternative 2.

            yyRepetition1 = yyChoice2;
            continue;
          }

        case '\n':
          {
            yyRepetition1 = yyIndex;
            continue;
          }

        case '/':
          {
            yyC = character(yyIndex);
            if (-1 != yyC) {
              yyIndex = yyIndex + 1;
              if ('/' == yyC) {

                yyRepetition2 = yyIndex;
                while (true) {

                  yyPredMatched = false;

                  yyPredResult = pEOL(yyRepetition2);
                  if (yyPredResult.hasValue()) {

                    yyPredMatched = true;
                  }

                  if (! yyPredMatched) {

                    yyC = character(yyRepetition2);
                    if (-1 != yyC) {
                      yyIndex = yyRepetition2 + 1;

                      yyRepetition2 = yyIndex;
                      continue;
                    }
                  } else {
                    yyError = yyError.select("spacing expected", yyStart);
                  }
                  break;
                }

                final int yyChoice2 = yyRepetition2;

                // Nested alternative 1.

                yyC = character(yyChoice2);
                if (-1 != yyC) {
                  yyIndex = yyChoice2 + 1;

                  switch (yyC) {
                  case '\r':
                    {
                      final int yyChoice3 = yyIndex;

                      // Nested alternative 1.

                      yyC = character(yyChoice3);
                      if ('\n' == yyC) {
                        yyIndex = yyChoice3 + 1;

                        yyRepetition1 = yyIndex;
                        continue;
                      }

                      // Nested alternative 2.

                      yyRepetition1 = yyChoice3;
                      continue;
                    }

                  case '\n':
                    {
                      yyRepetition1 = yyIndex;
                      continue;
                    }

                  default:
                    /* No match. */
                  }
                }

                // Nested alternative 2.

                yyPredMatched = false;

                yyC = character(yyChoice2);
                if (-1 != yyC) {

                  yyPredMatched = true;
                }

                if (! yyPredMatched) {

                  yyRepetition1 = yyChoice2;
                  continue;
                } else {
                  yyError = yyError.select("spacing expected", yyStart);
                }
              }
            }
          }
          break;

        default:
          /* No match. */
        }
      }

      // Nested alternative 2.

      yyResult = pMLComment(yyChoice1);
      yyError  = yyResult.select(yyError, yyRepetition1);
      if (yyResult.hasValue()) {

        yyRepetition1 = yyResult.index;
        continue;
      }
      break;
    }

    yyValue = null;

    return new SemanticValue(yyValue, yyRepetition1, yyError);
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.Space.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pSpace(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case ' ':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\t':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\f':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      case '\r':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if ('\n' == yyC) {
            yyIndex = yyChoice1 + 1;

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          }

          // Nested alternative 2.

          yyValue = null;

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '\n':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("space expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.EOL.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pEOL(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;

      switch (yyC) {
      case '\r':
        {
          final int yyChoice1 = yyIndex;

          // Nested alternative 1.

          yyC = character(yyChoice1);
          if ('\n' == yyC) {
            yyIndex = yyChoice1 + 1;

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          }

          // Nested alternative 2.

          yyValue = null;

          return new SemanticValue(yyValue, yyChoice1, yyError);
        }

      case '\n':
        {
          yyValue = null;

          return new SemanticValue(yyValue, yyIndex, yyError);
        }

      default:
        /* No match. */
      }
    }

    // Done.
    yyError = yyError.select("EOL expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.Comment.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pComment(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    Result     yyPredResult;
    boolean    yyPredMatched;
    int        yyRepetition1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('/' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('/' == yyC) {
        yyIndex = yyIndex + 1;

        yyRepetition1 = yyIndex;
        while (true) {

          yyPredMatched = false;

          yyPredResult = pEOL(yyRepetition1);
          if (yyPredResult.hasValue()) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyC = character(yyRepetition1);
            if (-1 != yyC) {
              yyIndex = yyRepetition1 + 1;

              yyRepetition1 = yyIndex;
              continue;
            }
          } else {
            yyError = yyError.select("comment expected", yyStart);
          }
          break;
        }

        final int yyChoice1 = yyRepetition1;

        // Nested alternative 1.

        yyC = character(yyChoice1);
        if (-1 != yyC) {
          yyIndex = yyChoice1 + 1;

          switch (yyC) {
          case '\r':
            {
              final int yyChoice2 = yyIndex;

              // Nested alternative 1.

              yyC = character(yyChoice2);
              if ('\n' == yyC) {
                yyIndex = yyChoice2 + 1;

                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

              // Nested alternative 2.

              yyValue = null;

              return new SemanticValue(yyValue, yyChoice2, yyError);
            }

          case '\n':
            {
              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }

          default:
            /* No match. */
          }
        }

        // Nested alternative 2.

        yyPredMatched = false;

        yyC = character(yyChoice1);
        if (-1 != yyC) {

          yyPredMatched = true;
        }

        if (! yyPredMatched) {

          yyValue = null;

          return new SemanticValue(yyValue, yyChoice1, yyError);
        } else {
          yyError = yyError.select("comment expected", yyStart);
        }
      }
    }

    // Alternative 2.

    yyResult = pMLComment(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {

      yyValue = null;

      return yyResult.createValue(yyValue, yyError);
    }

    // Done.
    yyError = yyError.select("comment expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.SLComment.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pSLComment(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyPredResult;
    boolean    yyPredMatched;
    int        yyRepetition1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('/' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('/' == yyC) {
        yyIndex = yyIndex + 1;

        yyRepetition1 = yyIndex;
        while (true) {

          yyPredMatched = false;

          yyPredResult = pEOL(yyRepetition1);
          if (yyPredResult.hasValue()) {

            yyPredMatched = true;
          }

          if (! yyPredMatched) {

            yyC = character(yyRepetition1);
            if (-1 != yyC) {
              yyIndex = yyRepetition1 + 1;

              yyRepetition1 = yyIndex;
              continue;
            }
          } else {
            yyError = yyError.select("s l comment expected", yyStart);
          }
          break;
        }

        final int yyChoice1 = yyRepetition1;

        // Nested alternative 1.

        yyC = character(yyChoice1);
        if (-1 != yyC) {
          yyIndex = yyChoice1 + 1;

          switch (yyC) {
          case '\r':
            {
              final int yyChoice2 = yyIndex;

              // Nested alternative 1.

              yyC = character(yyChoice2);
              if ('\n' == yyC) {
                yyIndex = yyChoice2 + 1;

                yyValue = null;

                return new SemanticValue(yyValue, yyIndex, yyError);
              }

              // Nested alternative 2.

              yyValue = null;

              return new SemanticValue(yyValue, yyChoice2, yyError);
            }

          case '\n':
            {
              yyValue = null;

              return new SemanticValue(yyValue, yyIndex, yyError);
            }

          default:
            /* No match. */
          }
        }

        // Nested alternative 2.

        yyPredMatched = false;

        yyC = character(yyChoice1);
        if (-1 != yyC) {

          yyPredMatched = true;
        }

        if (! yyPredMatched) {

          yyValue = null;

          return new SemanticValue(yyValue, yyChoice1, yyError);
        } else {
          yyError = yyError.select("s l comment expected", yyStart);
        }
      }
    }

    // Done.
    yyError = yyError.select("s l comment expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.MLComment.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pMLComment(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    Result     yyResult;
    int        yyPredIndex;
    boolean    yyPredMatched;
    int        yyBase;
    int        yyRepetition1;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if ('/' == yyC) {
      yyIndex = yyStart + 1;

      yyC = character(yyIndex);
      if ('*' == yyC) {
        yyIndex = yyIndex + 1;

        yyRepetition1 = yyIndex;
        while (true) {

          final int yyChoice1 = yyRepetition1;

          // Nested alternative 1.

          yyResult = pMLComment(yyChoice1);
          yyError  = yyResult.select(yyError, yyRepetition1);
          if (yyResult.hasValue()) {

            yyRepetition1 = yyResult.index;
            continue;
          }

          // Nested alternative 2.

          yyPredMatched = false;

          yyC = character(yyChoice1);
          if ('*' == yyC) {
            yyPredIndex = yyChoice1 + 1;

            yyC = character(yyPredIndex);
            if ('/' == yyC) {

              yyPredMatched = true;
            }
          }

          if (! yyPredMatched) {

            yyC = character(yyChoice1);
            if (-1 != yyC) {
              yyIndex = yyChoice1 + 1;

              yyRepetition1 = yyIndex;
              continue;
            }
          } else {
            yyError = yyError.select("m l comment expected", yyStart);
          }
          break;
        }

        yyBase = yyRepetition1;
        yyC    = character(yyBase);
        if ('*' == yyC) {
          yyIndex = yyRepetition1 + 1;

          yyC = character(yyIndex);
          if ('/' == yyC) {
            yyIndex = yyIndex + 1;

            yyValue = null;

            return new SemanticValue(yyValue, yyIndex, yyError);
          } else {
            yyError = yyError.select("'*/' expected", yyBase);
          }
        } else {
          yyError = yyError.select("'*/' expected", yyBase);
        }
      }
    }

    // Done.
    yyError = yyError.select("m l comment expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.Identifier.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pIdentifier(final int yyStart) throws IOException {
    WhileyIColumn yyColumn = (WhileyIColumn)column(yyStart);
    if (null == yyColumn.fIdentifier) 
      yyColumn.fIdentifier = pIdentifier$1(yyStart);
    return yyColumn.fIdentifier;
  }

  /** Actually parse whiley.WhileyI.Identifier. */
  private Result pIdentifier$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWord(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      if (! contains (KEYWORDS, yyValue)) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    yyError = yyError.select("identifier expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.Word.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pWord(final int yyStart) throws IOException {
    WhileyIColumn yyColumn = (WhileyIColumn)column(yyStart);
    if (null == yyColumn.fWord) yyColumn.fWord = pWord$1(yyStart);
    return yyColumn.fWord;
  }

  /** Actually parse whiley.WhileyI.Word. */
  private Result pWord$1(final int yyStart) throws IOException {
    Result     yyResult;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyResult = pWordCharacters(yyStart);
    yyError  = yyResult.select(yyError);
    if (yyResult.hasValue()) {
      yyValue = yyResult.semanticValue();

      yyResult = pSpacing(yyResult.index);
      yyError  = yyResult.select(yyError);
      if (yyResult.hasValue()) {

        return yyResult.createValue(yyValue, yyError);
      }
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.WordCharacters.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pWordCharacters(final int yyStart) throws IOException {
    int        yyC;
    int        yyIndex;
    int        yyRepetition1;
    String     yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyC = character(yyStart);
    if (-1 != yyC) {
      yyIndex = yyStart + 1;
      char h = (char)yyC;

      if (Character.isJavaIdentifierStart (h)) {

        yyRepetition1 = yyIndex;
        while (true) {

          yyC = character(yyRepetition1);
          if (-1 != yyC) {
            yyIndex = yyRepetition1 + 1;
            char t = (char)yyC;

            if (Character.isJavaIdentifierPart (t)) {

              yyRepetition1 = yyIndex;
              continue;
            }
          }
          break;
        }

        yyValue = difference(yyStart, yyRepetition1);

        return new SemanticValue(yyValue, yyRepetition1, yyError);
      }
    }

    // Done.
    yyError = yyError.select("word characters expected", yyStart);
    return yyError;
  }

  // =========================================================================

  /**
   * Parse nonterminal whiley.WhileyI.EOF.
   *
   * @param yyStart The index.
   * @return The result.
   * @throws IOException Signals an I/O error.
   */
  public Result pEOF(final int yyStart) throws IOException {
    int        yyC;
    boolean    yyPredMatched;
    Void       yyValue;
    ParseError yyError = ParseError.DUMMY;

    // Alternative 1.

    yyPredMatched = false;

    yyC = character(yyStart);
    if (-1 != yyC) {

      yyPredMatched = true;
    }

    if (! yyPredMatched) {

      yyValue = null;

      return new SemanticValue(yyValue, yyStart, yyError);
    } else {
      yyError = yyError.select("EOF expected", yyStart);
    }

    // Done.
    return yyError;
  }

  // =========================================================================

  /**
  * Drop the current path off string when it occurs at the beginning.
  */
  public String dropCurrentPath (String string) {
    int index = 0;
    int stringlen = string.length ();
    String prefix = System.getProperty ("user.dir");
    int prefixlen = prefix.length ();
    while ((index < stringlen) && (index < prefixlen) && (string.charAt (index) == prefix.charAt (index))) {
      index++;
    }
    if ((index != 0) && (string.charAt (index) == java.io.File.separatorChar)) {
      index++;
    }
    return string.substring (index);
  }
  
  /**
  * Format a Rats! parser error message according to Scala compiler
  * conventions for better compatibility with error processors.
  */
  public String formatParseError (ParseError error, Boolean showCoord) throws IOException {
    StringBuilder buf = new StringBuilder ();
    
    if (error.index == -1) {
      buf.append (error.msg);
    } else {
      Location loc = location (error.index);
      if (showCoord) {
        String filename = loc.file;
        buf.append (filename);
        buf.append (':');
        buf.append (loc.line);
        buf.append (": ");
      }
      
      buf.append (error.msg);
      buf.append ("\n");
      
      String line = lineAt (error.index);
      buf.append (line);
      buf.append ('\n');
      for (int i = 1; i < loc.column; i++) buf.append (' ');
      buf.append ("^");
    }
    
    return buf.toString ();
  }
  
  static {
    add (KEYWORDS, new String[] {
      "bool", "byte", "false", "int", "true"
    });
  }

  // =========================================================================

  /**
   * Add the specified values to the specified set.
   *
   * @param set The set.
   * @param values The new values.
   */
  protected static final <T> void add(Set<T> set, T[] values) {
    for (T v : values) set.add(v);
  }

  /**
   * Check whether the specified set contains the specified value.
   *
   * @param set The set.
   * @param value The value.
   * @return <code>true</code> if the set contains the value.
   */
  protected static final <T> boolean contains(Set<T> set, T value) {
    return set.contains(value);
  }

}
