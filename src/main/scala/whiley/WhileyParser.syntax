module whiley.WhileyI;

header {
    import whiley.WhileyISyntax.*;
}

Program =
    Spacing Stm* EOF.

Stm {line} =
    "package" Loc DotLoc*                                                                     {PackageDecl}
  | "import" LocOrStar "from" Loc DotLocOrStar*                                               {ImportDecl}
  | "public" Stm                                                                              {Public}
  | "private" Stm                                                                             {Private}
  | "native" Stm                                                                              {Native}
  | "export" Stm                                                                              {Export}
  | Type LVal CommTypeLoc* sp "=" Exp CommExp*                                                {DeclAsgn}
  | Type Loc                                                                                  {Decl}
  | Assign                                                                                    {AsgnStm}
  | "type" Loc sp "is" '('? Type Loc? ')'? WhereExpr*                                         {TypeDecl}
  | "const" Loc sp "is" Exp                                                                   {ConstDecl}                                                                  
  | "if" Exp ':' nest (Stm*)\n ElseIf* Else?                                                  {If}
  | "switch" Exp ':' CaseStm*                                                                 {Switch}
  | "while" Exp WhereExpr* ':' nest (Stm*)\n                                                  {While}
  | "do" ':' nest (Stm*)\n "while" nest (Exp) WhereExpr*                                      {DoWhile}
  | "function" Loc '(' Parameters? ')' ReturnType? RequiresEnsures* ':' nest (Stm*)\n         {FnDecl}
  | "method" Loc '(' Parameters? ')' ReturnType? RequiresEnsures* ':' nest (Stm*)\n           {MthdDecl}
  | "return" Exp CommExp*                                                                     {RtnStm}
  | "assert" Exp                                                                              {Assert}
  | "assume" Exp                                                                              {Assume}
  | "debug" Exp                                                                               {DebugExp}
  | "skip"                                                                                    {SkipStm}
  | "break"                                                                                   {BreakStm}
  | "continue"                                                                                {ContStm}
  | "fail"                                                                                    {FailStm}.

Type =
    UnionType                                                                                	{Union}
  | IntersectionType                                                                         	{IntrsctnType}
  | TermType.

UnionType : Type = 
    IntersectionType ('|' IntersectionType)*.

IntersectionType : Type = 
    TermType ('&' TermType)*.

TermType : Type = 
    RecordType                                                                                {RecType}
  | ReferenceType                                                                             {RefType}
  | NegationType                                                                              {NegType}
  |  ArrayType                                                                                {ArrType}
  | FunctionType                                                                              {FuncType}
  | MethodType                                                                                {MthdType}
  | '(' Type ')'
  | PrimitiveType.

PrimitiveType : Type =
    "null"                                                                                    {NullType}
  | "int"                                                                                     {IntType}
  | "byte"                                                                                    {ByteType}
  | "bool"                                                                                    {BoolType}
  | "real"                                                                                    {RealType}
  | Loc                                                                                       {NmnlType}.

RecordType : Type =
    '{' MixedType CommMixedType* ','? '...'? '}'.

MixedType = 
    Type Loc                                                                                  {Mix}
  | "function" Loc '(' Parameters ')' '->' Parameters                                         {MixFunc}
  | "method" Loc '(' Parameters ')' '->' Parameters                                           {MixMthd}.

CommMixedType = 
    ',' MixedType.

ReferenceType : Type =
    '&' Type.

NominalType : Type = 
    Loc.

ArrayType : Type = 
    PrimitiveType "[]".

NegationType : Type = 
    '!' Type.

FunctionType : Type = 
    "function" '(' Parameters ')' '->' Parameters.

MethodType : Type = 
    "method" '(' Parameters ')' '->' Parameters.

Exp {paren} = 
    Exp sp "<==>" Exp                                                                       {Iff, left, 10}
  | Exp sp "==>" Exp                                                                        {Implies, left, 9}
  | Exp sp "||" Exp                                                                         {Or, none, 8}
  | Exp sp "^" Exp																			{Xor, left, 7}
  | Exp sp "&&" Exp																			{And, left, 6}
  | Exp sp "&" Exp                                                                          {BitWiseAnd, left, 6}
  | Exp sp "==" Exp                                                                         {EQ, left, 5}
  | Exp sp "!=" Exp                                                                         {NE, left, 5}
  | Exp sp "<"  Exp                                                                         {LT, left, 4}
  | Exp sp "<=" Exp                                                                         {LE, left, 4}
  | Exp sp ">"  Exp                                                                         {GT, left, 4}
  | Exp sp ">=" Exp                                                                         {GE, left, 4}
  | Exp sp "<<" Exp                                                                         {Lsh, left, 3}
  | Exp sp ">>" Exp                                                                         {ARsh, left, 3}
  | Exp sp "+" Exp                                                                          {Add, left, 2}
  | Exp sp "-" Exp                                                                          {Sub, left, 2}
  | Exp sp "*" Exp                                                                          {Mul, left, 1}
  | Exp sp "/" Exp                                                                          {Div, left, 1}
  | Exp sp "%" Exp                                                                          {Rem, left, 1}
  | '!' Exp                                                                                 {Not}
  | '-' Exp                                                                                 {Neg}
  | Loc '(' Exp ')'                                                                         {FunctionCall}
  | '(' Exp ')'
  | '{' RecordInitialiser '}'
  | Exp '[' Exp ']'                                                                         {ArrAccess, left, 1}
  | '[' Exp ';' Exp ']'                                                                     {ArrGen}
  | '[' (Exp ',')* Exp ']'                                                                  {ArrInit}
  //| Exp ',' Exp                                                                             {ExpList, left, 1}
  | '&' Exp                                                                                 {RefExp}
  | Assign
  | Length
  | QuantExp                                                                                {QuantifierExp}                                                                               
  | Literal                                                                                 {Lit}
  | Loc                                                                                     {Use}.

RecordInitialiser : Exp =
    Loc ':' Exp CommLocColonExp*                                                            {RecInit}.

Assign : Exp = 
    LVal sp "=" Exp.

WhereExpr =
    "where" Exp                                                                             {WhereExp}.

QuantExp =
    NoSomeAll '{' Loc 'in' Exp CommLocInExp* '|' Exp '}'.

NoSomeAll = 
    "no"                                                                                    {No}
  | "some"                                                                                  {Some}
  | "all"                                                                                   {All}.

ElseIf = 
    "else if" Exp ':' nest (Stm*)\n.

Else =
    "else" ':' nest (Stm*)\n.

CaseStm = 
	"case" Exp CommExp* ':' nest (Stm*)\n                                                   {Case}
  | "default" ':' nest (Stm*)\n	                                                            {DefaultCase}.

RequiresEnsures = 
	"requires" Exp																			{Requires}
  | "ensures" Exp																			{Ensures}.

Parameters = 
    TypeLoc CommTypeLoc*                                                                    {Params}
  | Type CommType*                                                                          {TypeParam}.

ReturnType = 
    '->' '(' Parameters ')'                                                                 {RtnParams}
  | '->' Type                                                                               {RtnType}.

Literal =
    'null'																			        {NullLit} 
  | '0b' Bit*																			    {ByteLit}
  | IntegerLiteral                                                                          {IntLit, 1: Integer.parseInt : Int}
  | BooleanLiteral                                                                          {BoolLit}
  | CharacterLiteral
  | StringLiteral.

IntegerLiteral : Token =
    DecimalNumeral.

DecimalNumeral : String =
    '0'
  | NonZeroDigit Digits.

BooleanLiteral =
    'false'                                                                                 {False}
  | 'true'                                                                                  {True}.

CharacterLiteral : Literal = 
	"'" Character "'"																		{CharLit}.

StringLiteral : Literal =
	'"' Character* '"'																		{StringLit}.

Character : Token = 
	[\-a-zA-Z$._0-9].

Digits : String = 
	Digit*.

NonZeroDigit : String =
    [1-9].

Digit : String =
	[0-9].

Bit : Token = 
    [0|1].

// Used in Assign and DeclAsgn Statements
LVal = 
	Loc '.' Identifier 																		{FieldAsgn}
  | Loc '[' Exp ']'																			{ListAsgn}	
  | '*' Exp																					{Pointer}
  | Loc                                                                                     {LocAsgn}.

Loc = 
    Identifier.

Length : Exp = 
	'|' Loc '|'																				{Len}.

Lab : String =
	Identifier.

TypeLoc = 
    Type Loc.

CommTypeLoc : TypeLoc = 
    ',' TypeLoc.

CommExp = 
    ',' Exp.

CommLoc =
    ',' Loc.

CommLocInExp = 
    ',' Loc "in" Exp.

CommLocColonExp =
    ',' Loc ':' Exp.

CommLit =
    ',' Literal.

CommType = 
    ',' Type.
    
DotLoc =
    '.' Loc.

LocOrStar = 
    '*'                                                                                     {ImpAll}
  | Loc                                                                                     {Spcfc}.

DotLocOrStar = 
    '.' LocOrStar.