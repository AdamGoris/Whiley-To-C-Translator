module whiley.WhileyI;

header {
    import whiley.WhileyISyntax.*;
}

Program =
    Spacing Stm* EOF.

Stm {line} =
    "package" Loc DotLoc*                                                                     {PackageDecl}
  | "import" LocOrStar "from" Loc DotLocOrStar*                                               {ImportDecl}
  | Modifier Stm                                                                              {Modify}
  | Type LVal CommTypeLoc* sp "=" Exp CommExp*                                                {DeclAsgn}
  | Type LVal                                                                                 {Decl}
  | Assign                                                                                    {Asgn}
  | "type" Loc sp "is" '('? Type Loc? ')'? WhereExpr*                                         {TypeDecl}
  | "const" Loc sp "is" Exp                                                                   {ConstDecl}                                                                  
  | "if" Exp ':' nest (Stm*)\n ElseIf* Else?                                                  {If}
  | "switch" Exp ':' CaseStm*                                                                 {Switch}
  | "while" Exp WhereExpr* ':' nest (Stm*)\n                                                  {While}
  | "do" ':' nest (Stm*)\n "while" nest (Exp) WhereExpr*                                      {DoWhile}
  | "function" Loc '(' Parameters? ')' ReturnType? RequiresEnsures* ':' nest (Stm*)\n         {FnDecl}
  | "method" Loc '(' Parameters? ')' ReturnType? RequiresEnsures* ':' nest (Stm*)\n           {MthdDecl} 
  | "return" Exp CommExp*                                                                     {RtnStm}
  | "assert" Exp                                                                              {Assert}
  | "assume" Exp                                                                              {Assume}
  | "debug" Exp                                                                               {DebugExp}
  | "skip"                                                                                    {SkipStm}
  | "break"                                                                                   {BreakStm}
  | "continue"                                                                                {ContStm}
  | "fail"                                                                                    {FailStm}.

Type =
    TermType
  | UnionType                                                                                {Union}
  | IntersectionType                                                                         {IntrsctnType}.

UnionType : Type = 
    IntersectionType ('|' IntersectionType)*.

IntersectionType : Type = 
    TermType ('&' TermType)*.

TermType : Type = 
    RecordType                                                                                {RecType}
  | ReferenceType                                                                             {RefType}
  | ArrayType                                                                                 {ArrType}
  | NegationType                                                                              {NegType}
  | FunctionType                                                                              {FuncType}
  | MethodType                                                                                {MthdType}
  | '(' Type ')'
  | PrimitiveType
  | Identifier                                                                                {NmnlType}.

PrimitiveType : Type =
    "null"                                                                                    {NullType}
  | "int"                                                                                     {IntType}
  | "byte"                                                                                    {ByteType}
  | "bool"                                                                                    {BoolType}
  | "real"                                                                                    {RealType}.

RecordType : Type =
  '{' MixedType CommMixedType* ',' '...' '}'.

MixedType = 
    Type Loc                                                                                  {Mix}
  | "function" Loc '(' Parameters ')' '->' Parameters                                         {MixFunc}
  | "method" Loc '(' Parameters ')' '->' Parameters                                           {MixMthd}.

CommMixedType = 
    ',' MixedType.

ReferenceType : Type =
    '&' Type.

NominalType : Type = 
    Identifier.

ArrayType : Type = 
    PrimitiveType "[]".

NegationType : Type = 
    '!' Type.

FunctionType : Type = 
    "function" '(' Parameters ')' '->' Parameters.

MethodType : Type = 
    "method" '(' Parameters ')' '->' Parameters.

Exp {paren} = 
    Exp sp "<==>" Exp                                                                         {Iff, left, 10}
  | Exp sp "==>" Exp                                                                          {Implies, left, 9}
	|	Exp sp "||" Exp																																						{Or, none, 8}
  |	Exp sp "^" Exp																																						{Xor, left, 7}
  |	Exp sp "&&" Exp																																						{And, left, 6}
  | Exp sp "&" Exp                                                                            {BitWiseAnd, left, 6}
  |	Exp sp "==" Exp                                                                           {EQ, left, 5}
  | Exp sp "!=" Exp                                                                           {NE, left, 5}
  | Exp sp "<"  Exp                                                                           {LT, left, 4}
  | Exp sp "<=" Exp                                                                           {LE, left, 4}
  | Exp sp ">"  Exp                                                                           {GT, left, 4}
  | Exp sp ">=" Exp                                                                           {GE, left, 4}
  | Exp sp "<<" Exp                                                                           {Lsh, left, 3}
  | Exp sp ">>" Exp                                                                           {ARsh, left, 3}
  | Exp sp "+" Exp                                                                            {Add, left, 2}
  | Exp sp "-" Exp                                                                            {Sub, left, 2}
  | Exp sp "*" Exp                                                                            {Mul, left, 1}
  | Exp sp "/" Exp                                                                            {Div, left, 1}
  | Exp sp "%" Exp                                                                            {Rem, left, 1}
  | '!' Exp                                                                                   {Not}
  | '-' Exp                                                                                   {Neg}
  | Loc '(' Exp ')'                                                                           {FunctionCall}
  | '(' Exp ')'
  | Exp '[' Exp ']'                                                                           {ArrAccess, left, 1}
  | '[' Exp ';' Exp ']'                                                                       {ArrGen}
  | '[' (Exp ',')* Exp ']'                                                                    {ArrInit}
  | Exp ',' Exp                                                                               {ExpList, left, 1}
	| Assign
	| Length
  | QuantExp                                                                                  {QuantifierExp}
	| Loc                                                                                       {Use}                                                                               
  | Lit.

Assign : Exp = 
    LVal sp "=" Exp.

WhereExpr =
    "where" Exp                                                                               {WhereExp}.

QuantExp =
    NoSomeAll '{' Loc 'in' Exp CommLocInExp* '|' Exp '}'.

NoSomeAll = 
    "no"                                                                                      {No}
  | "some"                                                                                    {Some}
  | "all"                                                                                     {All}.

ElseIf = 
    "else if" Exp ':' nest (Stm*).

Else =
    "else" ':' nest (Stm*).

CaseStm = 
		"case" Exp CommExp* ':' nest (Stm*)\n                                                     {Case}
	| "default" ':' nest (Stm*)\n	                                                              {DefaultCase}.

RequiresEnsures = 
		"requires" Exp																																						{Requires}
	| "ensures" Exp																																							{Ensures}.

Parameters = 
    TypeLoc CommTypeLoc*                                                                      {Params}
  | Type                                                                                      {TypeParam}.

ReturnType = 
    '->' '(' Parameters ')'                                                                   {RtnParams}
  | '->' Type                                                                                 {RtnType}.

Modifier =
	  "public"																																									{Public}
	| "private"																																									{Private}
	| "native"																																									{Native}
	| "export"                                                                                  {Export}.

Lit : Exp =
		NullLiteral																																								{NullLit}
  | ByteLiteral																																								{ByteLit}
  | IntegerLiteral                                                                            {IntLit, 1: Integer.parseInt : Int}
  | BooleanLiteral																																						{BoolLit}
	| CharacterLiteral																																					{CharLit}
	| StringLiteral																																							{StringLit}.

NullLiteral =
		'null'.

ByteLiteral : Exp = 
  	'0b' Bit*.

IntegerLiteral : Token =
    DecimalNumeral.

DecimalNumeral : String =
    '0'
  | NonZeroDigit Digits.

BooleanLiteral : Exp =
    'false'                                                                                    {False}
  | 'true'                                                                                     {True}.

CharacterLiteral = 
		"'" Character "'".

StringLiteral  =
		 '"' Character* '"'.

Character : Token = 
		[\-a-zA-Z$._0-9].

Digits : String = 
		Digit*.

NonZeroDigit : String =
    [1-9].

Digit : String =
		[0-9].

Bit : String = 
    [0|1].

// Used in Assign and DeclAsgn Statements
LVal = 
		Loc '.' Identifier 																		                                      {FieldAsgn}
	| Loc '[' Exp ']'																				                                      {ListAsgn}	
	| '*' Exp																								                                      {Pointer}
	| Identifier																						                                      {IdnAsgn}.

Loc = 
    Identifier.

Length : Exp = 
		'|' Loc '|'																						                                      {Len}.

Lab : String =
		Identifier.

CommExp = 
    ',' Exp.

CommLoc =
    ',' Loc.

CommLocInExp = 
    ',' Loc "in" Exp.

CommLit =
    ',' Lit.

CommTypeLoc = 
    ',' TypeLoc.
    
DotLoc =
    '.' Loc.

LocOrStar = 
    '*'                                                                                          {ImpAll}
  | Loc                                                                                          {Spcfc}.

DotLocOrStar = 
    '.' LocOrStar.

TypeLoc = 
    Type Loc.
